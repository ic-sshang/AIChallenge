Intro
The Kubernetes SecretProviderClass, a CRD contained in the AKS CSI Driver helm chart, enables an Application/Workload to easily use an Azure KeyVault as a Configuration Source, and inject the KeyVault Secrets into the Kubernetes Pod via Environment variables and maintain a synchronization between the KeyVault and Pod during the lifecycle of the Pod updating the Environment Variables in the Pod when the KeyVault Secret changes.
Below are code snippets that outline how to setup a single instance of the SecretProviderClass and then inject them into a Pod as Environment Variables via a Volume Mount intermediary.
RESOURCE_GROUP=rg-pri-exampleapp-sbx

MANAGED_IDENTITY_NAME=mi-aks-pri-exampleapp-sbx

KEYVAULT_NAME=kv-pri-exampleapp-sbx

SECRET_PROVIDER_CLASS_NAME=azure-kv-exampleapp-secret-provider

KEYVAULT_SECRET_NAME=exampleapp-secret

K8S_SECRET_NAME=exampleapp-local-secret

ENV_SECRET_NAME=EXAMPLEAPP_ENV_SECRET

export USER_ASSIGNED_CLIENT_ID="$(az identity show -g ${RESOURCE_GROUP} -n ${MANAGED_IDENTITY_NAME} --query clientId -o tsv)"

export IDENTITY_TENANT="$(az account show --query tenantId -o tsv)"

APPLICATION_NAMESPACE=exampleapp-ns

cat <<EOF | kubectl apply -n $APPLICATION_NAMESPACE -f -
# This is a SecretProviderClass example using workload identity to access your key vault
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: ${SECRET_PROVIDER_CLASS_NAME} # needs to be unique per namespace
spec:
  provider: azure
  secretObjects:
  - secretName: ${K8S_SECRET_NAME}
    data:
    - key: key
      objectName: ${KEYVAULT_SECRET_NAME}
    type: Opaque
  parameters:
    usePodIdentity: "false"
    useVMManagedIdentity: "false"          
    clientID: ${USER_ASSIGNED_CLIENT_ID} # Setting this to use workload identity
    keyvaultName: ${KEYVAULT_NAME}       # Set to the name of your key vault
    cloudName: ""                         # [OPTIONAL for Azure] if not provided, the Azure environment defaults to AzurePublicCloud
    objects:  |
      array:
        - |
          objectName: ${KEYVAULT_SECRET_NAME}
          objectType: secret              # object types: secret, key, or cert
          objectVersion: ""               # [OPTIONAL] object versions, default to latest if empty
    tenantId: ${IDENTITY_TENANT}        # The tenant ID of the key vault
EOF

APPLICATION_NAMESPACE=exampleapp-ns

SERVICE_ACCOUNT_NAME=exampleapp-wi-sa

EXAMPLE_POD_NAME=secrets-store-inline-user-msi

cat <<EOF | kubectl apply -n $APPLICATION_NAMESPACE -f -
# This is a sample pod definition for using SecretProviderClass and the user-assigned identity to access your key vault
kind: Pod
apiVersion: v1
metadata:
  name: busybox-${EXAMPLE_POD_NAME}
spec:
  serviceAccountName: ${SERVICE_ACCOUNT_NAME}
  containers:
    - name: busybox
      image: k8s.gcr.io/e2e-test-images/busybox:1.29-1
      command:
        - "/bin/sleep"
        - "10000"
      env:
      - name: ${ENV_SECRET_NAME}
        valueFrom:
          secretKeyRef:
            name: ${K8S_SECRET_NAME}
            key: key
      volumeMounts:
      - name: secrets-${EXAMPLE_POD_NAME}
        mountPath: "/mnt/secrets-store"
        readOnly: true
  volumes:
    - name: secrets-${EXAMPLE_POD_NAME}
      csi:
        driver: secrets-store.csi.k8s.io
        readOnly: true
        volumeAttributes:
          secretProviderClass: ${SECRET_PROVIDER_CLASS_NAME}
EOF
 URL:/spaces/platform/pages/3061153882/Secret+Provider+Class