DRAFT
Overview
The primary data store for Biller data is partitioned over MS SQL database shards.  Each Biller has it own MS SQL database.  
Within the Biller definition there is a concept of a Demo Biller.  A Demo Biller is used for testing and demonstrations and does not need to meet production Biller SLAs.
Workload Processing
When defining new workloads that run for Billers there are some key concepts to take into consideration.
Can the work be done per Biller?
Can the source system trigger the work item for a single Biller?  Even if there are multiple items for billers, breaking the work down to per Biller provides advantages.   Using a event driven approach you can queue the work item for a individual Biller from the event source application.
Workloads should be run per biller
Having a workload run for the entire portfolio creates complexity as it relates to managing long running processing as well as the potential for one biller’s work to impact another biller’s work.
The ability to rerun workloads for a single biller provides a granular recovery process.
Demo billers should be isolated from production Billers
Demo Billers should not impact production Biller workload SLAs.   When obtaining work items be sure to separate production Billers from Demo Billers.  This can be done by the store procedure for database work items.  For message queues creating separate queues for Demo vs Production is desirable.
Workloads should be idempotent 
Idempotence means that no matter how many times you perform a certain operation, the result remains the same after the first execution. If you apply an idempotent operation once or a hundred times, the end state doesn’t change beyond the initial effect.
Reliability
: Imagine you’re building a distributed system where messages are sent between processes. If the message processing logic isn’t idempotent, a network hiccup or a temporary failure could lead to duplicate processing.  Idempotence ensures that even if the same message arrives multiple times, the system behaves consistently.  If a workload is run on a schedule or interval, a given run should not cause duplications within the workload items.
Retry Mechanisms
: In distributed systems, retries are common. Maybe a request times out or fails due to transient issues. If your API endpoints or backend services are idempotent, retries won’t cause unexpected behavior. The client can safely retry without worrying about creating duplicates or messing up the system state.
Caching and Memorization
: When caching results idempotence matters. If fetching the same resource repeatedly produces different results, caching becomes difficult. With idempotent operations, caching becomes more predictable and efficient.
Database Operations
: Consider database writes. If an operation inserting a record is idempotent, you won’t accidentally create duplicate entries. This is crucial for maintaining data integrity.
Idempotent APIs
: RESTful APIs should ideally have idempotent endpoints. For example, updating a user’s profile should be idempotent. If the client retries the same update, it shouldn’t corrupt up the user’s data.
 URL:/spaces/EA/pages/3427663877/Biller+Workloads