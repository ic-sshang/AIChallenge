none
Phase 1
In Progress Now
Simplify and standardize 1.0 components used in design​
Update 1.0 components for accessibility in Figma libraries​: 
Accessible Component Library 1.0
Track which components are ready for development: 
Design System Library
 
Implement updated components in prototypes
Phase 2
Weeks 1-10 
Build
 the system
10 weeks for all components to be fully complete (design review, frontend critiques, tests etc.)
*Timeline estimates account for the additional work being done in parallel with the Accessibility initiative and BMS work and any time lost waiting to get unblocked on any unforeseen blockers. 
Less than 10 weeks to get an MVP built for the vista-hackathon AI page before end of Q4 ‘24. 
(Won’t need all 35+ components for this one page, however we’ll still need some significant ones.)
Build cohesive, accessible, cross-product, component design system in React based upon updated 1.0 styles which would be a separate module which can expose our components to then be consumed by both a new Payer repo and a new Biller repo through the use of module federation.
Design system work already started here: 
https://ic-design-system.netlify.app/
 (will need adjustments)
Example architecture and folder structure
Example architecture showing use of module federation
Example hybrid structure
2
1
0
0
3549888517
3548151819
1
Architecture.drawio
3
3
https://invoicecloud.atlassian.net/wiki
Architecture.drawio
0
766
1041
payer-portal example
2
1
0
0
3549724721
3548151819
1
MyIIS-example.drawio
2
2
https://invoicecloud.atlassian.net/wiki
MyIIS-example.drawio
0
605
625
Example folder structure
design-system
design-system/src
├── components/
│   ├── ButtonPrimary.tsx
│   ├── Modal.tsx
│   ├── Input.tsx
│   └── ...etc
├── pages
│   ├── _app.tsx
│   ├── _document.tsx
│   ├── index.tsx                # Display components here (like a storybook)
└── style-guide
payer-portal
payer-portal/
├── pages/
│   ├── _app.tsx
│   ├── _document.tsx
│   ├── index.tsx                # Landing page
│   ├── account/                 
│       └── index.tsx            # Dynamically imports 'account' micro-frontend
│   ├── profile/
│       └── index.tsx            # Dynamically imported m-fe as well
│   ├── support/
│       └── index.tsx            # Dynamically imported m-fe as well
│   ├── autoPay/
│       └── index.tsx            # Dynamically imported m-fe as well
│   ├── paperless/
│       └── index.tsx            # Dynamically imported m-fe as well
│   ├── payByText/  
│       └── index.tsx            # Dynamically imported m-fe as well   
│   ├── 404.tsx                  # Non m-fe domain pages catch-all in this repo
│   ├── API/ 
├── components/                  # Shared payer-specific components (header, etc.)
├── public/
├── package.json                 
├── tsconfig.json
└── next.config.js              # Module federation setup. Consume the remotes
account (micro-frontend)
account/
├── pages/
│   ├── _app.js
│   ├── _document.js
│   ├── index.js
│   ├── CustomerGroupLedger/
│       └── Page.tsx
│   ├── CustomerGroupSchedulePayments/
│       └── Page.tsx
│   ├── CustomerGroupPaymentHistory/
│       └── Page.tsx
│   ├── API/
├── components/
│   └── DashboardWidgets.tsx
├── package.json                 
├── tsconfig.json
└── next.config.js              # Expose micro-frontend module
Example webpack configuration
payer-portal
This will consume both the design-system and all of the micro-frontends.
next.config.js
js
const NextFederationPlugin = require("@module-federation/nextjs-mf");
const { FederatedTypesPlugin } = require("@module-federation/typescript");

const nextConfig = {
  reactStrictMode: true,
  typescript: {
    ignoreBuildErrors: true,
  },
  webpack(config, options) {
    const { isServer } = options;
    const remotes = {
      'design-system': `design-system@http://localhost:3001/_next/static/chunks/remoteEntry.js`,
      'account': `account@http://localhost:3002/_next/static/chunks/remoteEntry.js`,
      'profile': `profile@http://localhost:3003/_next/static/chunks/remoteEntry.js`,
      'support': `support@http://localhost:3004/_next/static/chunks/remoteEntry.js`,
      'autoPay': `autoPay@http://localhost:3005/_next/static/chunks/remoteEntry.js`,
      'paperless': `paperless@http://localhost:3006/_next/static/chunks/remoteEntry.js`,
      'payByText': `payByText@http://localhost:3007/_next/static/chunks/remoteEntry.js`,
    },
  };
  const federatedConfig = {
    name: "payer-portal",
    remotes: remotes,
    shared: {
      // react/next is shared automatically
    },
  };
  config.plugins.push(
    new NextFederationPlugin(federatedConfig),
    new FederatedTypesPlugin({ federationConfig })
  );
    
    return config;
  },
};

module.exports = nextConfig;
(payer-portal) package.json
js
"scripts": {
  "dev": "NEXT_PRIVATE_LOCAL_WEBPACK=true next dev"
}
design-system
This repo will expose its components so that the other apps can consume them.
next.config.js
js
const NextFederationPlugin = require("@module-federation/nextjs-mf");
const { FederatedTypesPlugin } = require("@module-federation/typescript");

const federatedConfig = {
  name: "design-system",
  filename: "static/chunks/remoteEntry.js",
  exposes: {
    './Button': './src/components/Button', // Expose components
    './Input': './src/components/Input',
    // Add other components we want to expose
  },
  shared: {
    // react/next is shared automatically
  },
};

const nextConfig = {
  reactStrictMode: true,
  typescript: {
    ignoreBuildErrors: true,
  },
  webpack(config, options) {
    config.plugins.push(
      new NextFederationPlugin(federatedConfig),
      new FederatedTypesPlugin({ federationConfig })
    );
    return config;
  },
};

module.exports = nextConfig;
(design-system) package.json
js
"scripts": {
  "dev": "NEXT_PRIVATE_LOCAL_WEBPACK=true next dev -p 3001"
}
account (micro-frontend)
Each micro-frontend like 
account 
will consume both the design-system and shared dependencies from payer-portal.
next.config.js
js
const NextFederationPlugin = require("@module-federation/nextjs-mf");
const { FederatedTypesPlugin } = require("@module-federation/typescript");

const federatedConfig = {
  name: "account",
  filename: "static/chunks/remoteEntry.js",
  exposes: {
    'account': `account@http://localhost:3001/_next/static/chunks/remoteEntry.js`,
  },
  remotes: {
    'design-system': `design-system@http://localhost:3001/_next/static/chunks/remoteEntry.js`,
  },
  shared: {
    // react/next is shared automatically
  },
};

const nextConfig = {
  reactStrictMode: true,
  typescript: {
    ignoreBuildErrors: true,
  },
  webpack(config, options) {
    config.plugins.push(
      new NextFederationPlugin(federatedConfig),
      new FederatedTypesPlugin({ federationConfig })
    );
    return config;
  },
};

module.exports = nextConfig;
(account) package.json
js
"scripts": {
  "dev": "NEXT_PRIVATE_LOCAL_WEBPACK=true next dev -p 3002"
}
Next.js library that enables Module Federation support.
https://www.npmjs.com/package/@module-federation/nextjs-mf
 
This plugin works by hooking into Next.js’s Webpack config and allows you to define module federation settings. (Nextjs does not support module federation natively.) Also, install TS support & webpack since the later versions don’t include it by default.
npm i @module-federation/nextjs-mf @module-federation/typescript webpack
Next, modify next.config.mjs
Routing example
“To avoid hydration errors, use React.lazy instead of next/dynamic for lazy loading federated components.” (
https://www.npmjs.com/package/@module-federation/nextjs-mf
 )
js
// payer-portal/src/pages/account/index.tsx

import { lazy } from 'react';

const AccountPage = lazy(() => import('account/pages/index'));

export default function Account() {
  return <AccountPage />;
}
This imports the remote module from the 
account
 micro-frontend. Next.js will route 
/account
 as normal, but the actual page (component) is dynamically loaded from the micro-frontend via Module Federation.
Steps
Set up new cross-product design system using React + Next.js (Martin to help set up the official repo for us in Azure.)
Story item for each component? 35+ total components 
(estimate story points for each depending upon complexity)
Need to build with the following top of mind:
Accessibility
Composability (we want to avoid devs feeling like they have to create one-off variant components at all costs)
Reusability
Maintainability
Design guard rails: i.e. how the components are expected to be used, what props do they accept, what types are allowed for certain props etc. Ex: errors thrown if accessibility props are ignored.
Need to also build components in a way that they can be easily styled for the Payer or Biller context. Components would dynamically receive different styles depending on the context in which they are imported into, (Biller or Payer portal)​ (useContext hook potentially)
We need to be careful to ensure that our shared components contain only UI logic, and no business or domain logic. When domain logic is put into a shared library it creates a high degree of coupling across applications, and increases the difficulty of change
Weekly design review of components 
concurrently
 
as we’re building them 
utilizing Figma Code Connect with the design team.
Why use Next.js?
Benefits of Next.js
React’s answer
“You can use React without a framework, however we’ve found that most apps and sites eventually build solutions to common problems such as code-splitting, routing, data fetching, and generating HTML. These problems are common to all UI libraries, not just React.
By starting with a framework, you can get started with React quickly, and 
avoid essentially building your own framework later.
” – 
Can I use React without a framework?
 
Automatic Code-Splitting
Next.js automatically splits the code for each page into its own bundle. Only the JS and CSS necessary for the current page are loaded (performance)
Even though we’d be using module federation to dynamically load remote modules, Next.js’s built-in code-splitting optimizes the loading of local routes.
If a route is not federated, you still benefit from optimized page bundle sizes without needing to configure webpack manually.
Static Generation (SSG) and Server-Side Rendering (SSR)
The pages router supports both - allowing us to choose between static, dynamic, or hybrid approaches for our routes.
We can still use SSR for pages that don’t need to load micro-frontends, which will improve SEO and initial page performance (time-to-first-byte)
When using module federation, static or server-side rendering can still be applied to non-remote pages, while dynamic federated components are only loaded on. the client side. This gives us fine-grained control over how each page is rendered.
Federated pages can still use client-side loading while keeping static or server-rendered routes fast.
Incremental Static Regeneration (ISR)
With the pages router, Next.js provides (ISR), where we can statically generate pages at build time and then regenerate them on-demand at runtime. This is useful for pages that don’t involve micro-frontends but still need dynamic content without sacrificing the benefits of static generation.
While this doesn’t directly affect federated routes, it allows you to optimize other non-federated parts of our app.
File-based routing
Each file in the 
pages
 folder automatically becomes a route.
This provides an intuitive way to manage local routes while allowing you to offload certain routes to micro-frontends via module federation.
You can still use dynamic routes (
[slug].tsx
) for more complex URL structures, providing flexibility for both local and federated components.
API Routes
The pages router also supports API routes, enabling you to define serverless functions or backend logic directly within your app.
These API routes can be used for data fetching or interactions with remote micro-frontends, providing a unified backend and frontend experience.
Next.js baked in accessibility features
 like an A11y linter and route change announcer
Built in 
optimizations
 
Image handling: Next.js’s image optimization automatically handles image resizing, lazy loading, and serving the correct image format for each device (like WebP).
Fast Refresh
Enables instant feedback when editing code in dev mode. Even though we’re working with federated micro-frontends, the local routes still benefit from this feature, which speeds up development workflow, allowing us to make changes and see the results immediately, even when dealing with multiple repos for micro-frontends.
https://nextjs.org/docs/getting-started/installation#automatic-installation
 
What is your project named? design-system
Would you like to use TypeScript? Yes
Would you like to use ESLint? Yes
Would you like to use Tailwind CSS? No
Would you like to use `src/` directory? Yes
Would you like to use App Router? (recommended) No (not compatible w/ module federation bc of the emphasis on server components and server-first rendering)
Would you like to customize the default import alias (@/*)? Yes
What import alias would you like configured? @/*
npm i --save-dev sass
Aside: Figma Code Connect
Figma Code Connect
Figma Code Connect
“With Code Connect, bring your design system component code directly into Figma's Dev Mode…When using Code Connect, Dev Mode displays real world code snippets defined by your design system 
instead of the autogenerated code
 snippets that Dev Mode provides by default.”
The Right Code for Your Design System | Figma Blog
“when a developer clicks on a mockup, they don’t need to search through a bunch of documentation and code to figure out how to build it in the design system. Instead, they just click on it and get the approved, maintained code samples they need, published by the design systems team.
This has huge benefits: Since developers aren’t rewriting components, there’s less code to maintain. By using what’s already there—
rather than creating components from scratch
—developers can work more efficiently and effectively. And with better adherence to your design system, you can more easily improve accessibility and consistency across applications.”
code-connect/cli/README.md at main · figma/code-connect
 (React installation instructions)
Pros
Designers already use Figma and front end devs/PMs are already familiar with it
Supports React specifically
Free with our current account?
Can see components in context of design and view code snippets
Cons
In beta at the moment.
Components (Atoms)
*Starting point (unofficial repo): 
https://github.com/Billybobchops/design-system
 
Accordion
Figma link
Story Points: 2
Already started here: 
https://ic-design-system.netlify.app/
 
Alert
Figma link
Story points: 1
Already started here: 
https://ic-design-system.netlify.app/
 
Badge
Figma link
Story points: 1
Already started here: 
https://ic-design-system.netlify.app/
 
Primary Button
Figma link
Story points: 1
Already started here: 
https://ic-design-system.netlify.app/
 
Secondary Button
Figma link
Story points: 1
Already started here: 
https://ic-design-system.netlify.app/
 
Tertiary Button
Figma link
Story points: 1
Already started here: 
https://ic-design-system.netlify.app/
 
Action Button
Figma link
Story points: 1
Already started here: 
https://ic-design-system.netlify.app/
 
Link Icon Button
Figma link
Story points: 2
Already started here: 
https://ic-design-system.netlify.app/
 
Card
Figma link
Story points: 3
Checkbox
Figma link
Story points: 2
Already started here: 
https://ic-design-system.netlify.app/
 
Data Table: Basic Header
Figma link
Story points: 1
Data Table: Sort Header
Figma link
Story points: 3
Data Table: Checkbox Header
Figma link
Story points: 2
Data Table: Nested Header
Figma link
Story points: 1
Data Table: Row Action Expandable
Figma link
Story points: 3 +
Data Table: Row Action Checkbox
Figma link
Story points: 2
Data Table: Cell
Figma link
Story points: 2
Data Table: Pagination
Figma link
Story points: 3
Data Table: Action Bar
Figma link
?
Story points: ?
Date Picker
Figma link
Story points: 5
Already started here: 
https://ic-design-system.netlify.app/
 
Dialog
Figma link
Story points: 5
Already started here: 
https://ic-design-system.netlify.app/
 
Divider
Figma link
Story points: 1
Already started here: 
https://ic-design-system.netlify.app/
 
Dropdown
Figma link
Story points: 3
Enroll Status
 (Payer only)
Figma link
Story points: 3
Already started here: 
https://ic-design-system.netlify.app/
 
Text Input
Figma link
Story points: 5
Already started here: 
https://ic-design-system.netlify.app/
 
Phone Number Input
Figma link
Story points: 5
Input Group Text Field
 (Monetary Input)
Figma link
Story points: 5
Modal
Figma link
Story points: 5
Already started here: 
https://ic-design-system.netlify.app/
 
Multi-select
Figma link
Story points: 3
Pagination
Figma link
Story points: 3
Progress Indicator
Figma link
Story points: 3
Radio Button
Figma link
Story points: 3
Already started here: 
https://ic-design-system.netlify.app/
 
Select
Figma link
Story points: 3
Tabs
Figma link
Story points: 3
Already started here: 
https://ic-design-system.netlify.app/
 
Tooltip
Figma link
Story points: 3
Link
 Figma link (N/A)
Story points: 1
Already started here: 
https://ic-design-system.netlify.app/
 
Icon
Figma link (N/A)
Story points: 3
Already started here: 
https://ic-design-system.netlify.app/
 
Total Estimated: 94 points
Weeks 11-14 
Use
 the system -- 
Build
 page 1
4 weeks
Build vista-hackathon reporting page first before end of Q4 '24
https://vista-hackathon-ui-win.azurewebsites.net/index.html
Steps
Martin to help set up new Biller and Payer repos in Azure
Build out specific molecules/organisms that will get reused on many pages
Example: Header component made up of smaller imported components like links, drop downs, etc.
Example: Footer component, etc.
Build out the Hackathon page in the Biller repo
Weeks 15 - xx 
Begin building 
all the payer pages
xx weeks …
Martin to assist in page selection
114+ pages in MyIIS to migrate and consolidate
Consolidate the number of pages down with the use of components and state
Do we need an entire page for things like AutoPayConfirm?
We likely won’t need multiple “Master” pages either.
Don’t need a page for a loading state: LoadingCustomerLinkedAccounts.aspx
API Driven Development
Back end devs build out the APIs for each page ahead of the front end dev work
Always one page ahead - then front end devs can consume the API
Micro-frontends + microservices
Payer Portal Pages (114+)
AccountLocator.aspx
Do the results need to be a separate, additional page? Or can these be consolidated to a single page with reactive components?
AccountLocatorResults.aspx
AutoPay.aspx
Does AutoPayConfirm really need to be a separate page?
AutoPayConfirm.aspx
Bank.aspx
Does BankDelete need to be a separate page? Or could it be a modal/dialogue?
BankDelete.aspx
CartPaymentConfirmation.aspx
ChangeScheduledPaymentDate.aspx
CloudPayment.aspx
CloudPaymentConfirmation.aspx
CloudPaymentDonation.aspx
CloudPaymentFlexPay.aspx
CloudPaymentInvoices.aspx
CloudPaymentMethod.aspx
CloudPaymentRelatedInvoices.aspx
CloudPaymentReview.aspx
CloudPaymentSignIn.aspx
CloudStore.aspx
CoudStoreConfirmation.aspx
CloudStoreReview.aspx
Confirmation.aspx
ContactUs.aspx
CreditCard.aspx
CreditCardDelete.aspx
Customer.aspx
Is this page still in use?
CustomerDocumentHandler.ashx
CustomerDocuments.aspx
CustomerFeaturePaperless.aspx
Is this page still in use?
CustomerGroupAccounts.aspx
CustomerGroupAutoPay2.aspx
CustomerGroupChangeAccountInfo.aspx
CustomerGroupChangeLoginInfo.aspx
CustomerGroupChangePassword.aspx
CustomerGroupLedger.aspx
CustomerGroupMakePaymentConfirmation.aspx
CustomerGroupNewTicket.aspx
CustomerGroupPaperInvoices.aspx
CustomerGroupPayByText.aspx
CustomerGroupPaymentHistory.aspx
CustomerGroupPaymentOptions.aspx
CustomerGroupRecurringScheduledPayments.aspx
CustomerGroupScheduledPayments.aspx
CustomerGroupTickets.aspx
CustomerInvitationError.aspx
CustomerInvitationHandler.ashx
CustomerLoanSummary.aspx
CustomerLocator.aspx
Do the results need to be 2 separate, additional pages? Or can these be consolidated to a single page with reactive components?
CustomerLocatorRelatedResults.aspx
CustomerLocatorResults.aspx
CustomerLogin.aspx
CustomerLoginDelete.aspx
CustomerLoginEdit.aspx
CustomerLoginInvitation.aspx
CustomerLoginInviteActions.aspx
CustomerLoginManagement.aspx
CustomerLogout.aspx
CustomerLostPassword.aspx
CustomerLostUsername.aspx
CustomerMLS.aspx
CustomerNoInvoice.aspx
Does this page get utilized?
CustomerPasswordReset.aspx
CustomerPayNearMe.aspx
Does this page get utilized?
CustomerPortal1.master
These 2 may be able to be consolidated
CustomerPortal2.master
CustomerReactAuth.aspx
???
CustomerRegistration.aspx
Can these 3 be consolidated into one page?
CustomerRegistrationMLS.aspx
CustomerRegistrationMultiple.aspx
CustomerSelectedInvoices.aspx
CustomerService.aspx
CustomerStyle.ashx
CustomerTicketDetail.aspx
 CustomerTXTReminder.aspx
CustomerUnifyAccounts.aspx
Delete?
CustomerWelcome.aspx
DeleteRecurringScheduledPayment.aspx
EnsurePaymentMethodAvailable.aspx
Error.aspx
ExternalPage.master
All 7 of these can likely be consolidated down somewhat
ExternalPage2.master
ExternalPage3.master
ExternalPage4.master
ExternalPageForIframe.master
ExternalPageSSO.master
ExternalPageSSO2.master
FeesDisclosure.aspx
FlexPaymentScheduleDelete.aspx
IC_404.aspx
InvoiceAdjustments.aspx
InvoicePayments.aspx
InvoiceReminder.aspx
InvoiceSPAPHistory.aspx
InvoicesRefreshHistory.aspx
LinkAccounts.aspx
LoadingCustomerLinkedAccounts.aspx
Don’t need a whole page to display a loading state
Maintenance.aspx
MasterCustomerPortal.master
These master pages may be able to be consolidated
MasterExternalPage.master
MasterExternalPageSSO.master
MasterSSO1.master
NfgExternalLinks.ashx
OneClickPayHandler.aspx
OptOutConfirm.aspx
PaperlessConfirm.aspx
PaymentMethodHistory.aspx
RecurringScheduledPayment.aspx
RemoveLogin.aspx
SavePaymentMethod.aspx
ScheduledPaymentDelete.aspx
SendPaymentLink.aspx
Site.aspx
These may be able to be consolidated 
Site2.aspx
testing.aspx
Delete?
UnlinkAccount.aspx
Phase 3
Swiftly migrate to updated look and feel via individual component style updates​ 
Update component in one file and it updates across the entire portal
Weeks xx - xx
4-6 weeks 
 URL:/spaces/PRODUCT/pages/3381493786/Modernization+Roadmap