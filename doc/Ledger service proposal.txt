Purpose
The 
Ledger Service
 is a standalone, double-entry accounting system designed to record and audit all financial transactions across services such as 
Payments
 and 
Funding
. It ensures 
financial integrity
, 
idempotency
, 
auditability
, and 
reporting readiness
.
The intention is to keep track of money movement for sale and refunds.
For sale the following money movement needs to be recorded:
Payer to Chase (debit)
Chase to IC (credit)
For refund we’ll have it in the other direction:
Biller to Chase (debit)
Chase to IC (credit)
IC to Chase (debit)
Chase to Payer (credit)
(or would it be Biller to Chase to Payer without IC?)
For funding we’ll need to record the following money movement:
IC to Chase (the fact of sending NACHA file with funding instructions to Chase) (debit)
Chase to Biller (once Chase confirms that the Biller got funded) (credit)
Why a Separate Ledger Service?
Reason
Description
Separation of Concerns
Keeps financial logic isolated from business logic in Payments, Funding, etc.
Auditability
Centralized audit logs and immutable transaction records.
Consistency
Enforces double-entry accounting rules across all services.
Idempotency
Prevents duplicate financial records via reference_id.
Reporting
Enables unified financial reporting across domains.
Extensibility
Supports new transaction types (e.g., fees, adjustments) without changing core services.
Data Model
DB diagram for ledger schema
Data dictionary for the ledger schema
Table: TransactionTypes
Purpose
: Defines the types of financial transactions (e.g., Payment, Refund, Funding).
Column Name
Data Type
Description
Id
int (PK)
Unique identifier for the transaction type
Name
nvarchar(100)
Name of the transaction type (e.g., Payment, Refund)
Table: Accounts
Purpose
: Stores financial accounts used in ledger transactions. Supports multiple producers and system-level accounts.
Column Name
Data Type
Description
AccountId
int (PK, auto)
Unique numeric ID for the account
Name
nvarchar(100)
Display name of the account
AccountType
nvarchar(50)
Type of account (e.g., customer, chase, invoicecloud)
SourceSystem
nvarchar(100)
Originating system (e.g., payments-service, funding-service)
ExternalReferenceId
nvarchar(100)
External ID from the source system (e.g., CustomerID, SubmerchantKey)
CurrencyCode
char(3)
ISO currency code (e.g., USD, EUR)
Balance
decimal(18,2)
Current balance of the account
CreatedAt
datetime2
Timestamp when the account was created
Table: LedgerEntries
Purpose
: Records individual financial movements between accounts.
Column Name
Data Type
Description
Id
int (PK, auto)
Unique identifier for the ledger entry
ReferenceId
nvarchar(100)
External reference for the transaction (e.g., payment ID)
SourceSystem
nvarchar(100)
Originating system of the transaction
AccountId
int
Foreign key to Accounts.AccountId
EntryType
nvarchar(10)
Either debit or credit
Amount
decimal(18,2)
Amount of the transaction (must be > 0)
CurrencyCode
char(3)
ISO currency code
Description
nvarchar(255)
Optional description of the transaction
TransactionTypeId
int
Foreign key to TransactionTypes.Id
CreatedAt
datetime2
Timestamp when the entry was created
Table: AuditLogs
Purpose
: Tracks changes and actions performed on ledger entities for traceability and compliance.
Column Name
Data Type
Description
Id
int (PK, auto)
Unique identifier for the audit log entry
EntityType
nvarchar(100)
Type of entity being audited (e.g., LedgerEntry, Account)
EntityId
int
ID of the entity being audited
Action
nvarchar(50)
Action performed (e.g., Insert, Update, Reverse)
Data
nvarchar(max)
JSON or text snapshot of the change
CreatedAt
datetime2
Timestamp of the audit event
API Contracts
POST api/v1/debit
Purpose:
 records a transaction funds are debited from one account and credited to another
json
{
  "reference_id": "txn-001",
  "source_system": "payments-service",
  "debit_account_id": 101,         // e.g., Payer account
  "credit_account_id": 1,          // e.g., Chase account
  "amount": 100.00,
  "currency_code": "USD",
  "description": "Customer payment for invoice #123",
  "transaction_type_id": 1
}

Behavior
Validates idempotency using 
reference_id + source_system
.
Ensures both accounts exist and have matching currency.
Checks sufficient funds in the debit account.
Inserts two 
LedgerEntries
: one debit, one credit.
Updates balances accordingly.
Logs actions in 
AuditLogs
.
 
POST api/v1/credit
Purpose
: Records a transaction where funds are credited to one account and debited from another (semantically reversed).
Same structure as 
api/v1/debit
, but:
credit_account_id
: recipient
debit_account_id
: source
Used for refunds, reversals, or funding.
GET api/v1/accounts/{account_id}/balance
Returns current balance.
GET api/v1/accounts/{account_id}/entries
Returns ledger entries with optional filters:
from_date, to_date
transaction_type_id
currency_code
GET api/v1/transactions/{reference_id}
Returns both debit and credit entries for a transaction.
POST api/v1/transactions/reverse
Reverses a transaction by creating a new one with inverted entries.
Accounts
Ledger will own its own accounts table, which will be built based on payer, biller, chase and IC account IDs passed to the ledger debit/credit APIs.
The suggested format for the accounts would be:
Actor
Ledger Account ID Format
Notes
Payer
account-payer-{InvoiceID}
 (todo think if there could be any issues with that)
Unique per payer. To be provided by ICChasePaymentProcessingAPI. 
CustomerID
 refers to the Customers table in Payments schema.
Chase
account-chase
Single static account for Chase
InvoiceCloud
account-invoicecloud-{id}
Multiple static accounts for InvoiceCloud.
Biller
account-merchant-{merchantID}
Will be provided during funding.
Ledger can resolve accounts by running the following query: 
sql
SELECT Id FROM Accounts
WHERE SourceSystem = 'payments-service'
  AND ExternalReferenceId = '123'
  AND AccountType = 'payer';

Integration with Other Services
During the Payer->Chase->InvoiceCloud phase, the caller for the ledger operations will be ICChasePaymentProcessingAPI service
There will be two phases as far as the payment processing is concerned.
Phase 1: During Payment Processing
Trigger
: Payer initiates payment.
Action
: ICChasePaymentProcessingAPI service calls Ledger service to record 
Payer → Chase
.
json
POST /transactions/debit
{
  "reference_id": "pay-123-step1",
  "source_system": "payments-service",
  "debit_account_id": "account-payer-456",     // derived from Payments.CustomerID
  "credit_account_id": "account-chase",            // static system account
  "amount": 100.00,
  "currency_code": "USD",
  "description": "Payment for invoice #789",
  "transaction_type_id": 1
}

Phase 2: After Chase Confirms Money Movement
Trigger
: IC receives money movement confirmation through NACHA file.
Action
: The receiver of the confirmation calls ICChasePaymentProcessingAPI service to update payment status, which will call the Ledger to record 
Chase → InvoiceCloud
.
json
POST /transactions/debit
{
  "reference_id": "txn-001-step2",
  "source_system": "payments-service",
  "debit_account_id": "account-chase", // static system account
  "credit_account_id": "account-invoicecloud", // static system account
  "amount": 100.00,
  "currency_code": "USD",
  "description": "Money movement to InvoiceCloud for invoice #123",
  "transaction_type_id": 2
}

Appendix A. Ledger schema in DBML
sql

Table TransactionTypes {
  Id int [pk, increment]
  Name nvarchar(100) [not null, unique]
}

Table Accounts {
  Id int [pk, increment]
  Name nvarchar(100) [not null]
  Balance decimal(18,2) [not null, default: 0]
  CurrencyCode char(3) [not null]
  CreatedAt datetime2 [default: `SYSDATETIME()`]

  AccountType nvarchar(50) [not null, note: 'e.g., payer, chase, invoicecloud, merchant']
  SourceSystem nvarchar(100) [note: 'System that owns or created the account, e.g., payments-service, funding-service']
  ExternalReferenceId nvarchar(100) [note: 'ID from the source system, e.g., CustomerID or MerchantID']
}

Table LedgerEntries {
  Id int [pk, increment]
  ReferenceId nvarchar(100) [not null]
  SourceSystem nvarchar(100) [not null]
  AccountId int [not null, ref: > Accounts.Id]
  EntryType nvarchar(10) [not null, note: 'Must be either debit or credit']
  Amount decimal(18,2) [not null, note: 'Must be greater than 0']
  CurrencyCode char(3) [not null]
  Description nvarchar(255)
  TransactionTypeId int [not null, ref: > TransactionTypes.Id]
  CreatedAt datetime2 [default: `SYSDATETIME()`]

  indexes {
    (ReferenceId, SourceSystem) [unique]
  }
}

Table AuditLogs {
  Id int [pk, increment]
  EntityType nvarchar(100)
  EntityId int
  Action nvarchar(50)
  Data nvarchar(max)
  CreatedAt datetime2 [default: `SYSDATETIME()`]
}

Appendix B. Proposed logic to record credits and debits
post_debit
sql
CREATE PROCEDURE post_debit
    @ReferenceId NVARCHAR(100),
    @SourceSystem NVARCHAR(100),
    @DebitAccountId UNIQUEIDENTIFIER,
    @CreditAccountId UNIQUEIDENTIFIER,
    @Amount DECIMAL(18, 2),
    @CurrencyCode CHAR(3),
    @Description NVARCHAR(255),
    @TransactionTypeId INT
AS
BEGIN
    SET NOCOUNT ON;

    IF EXISTS (
        SELECT 1 FROM LedgerEntries
        WHERE ReferenceId = @ReferenceId AND SourceSystem = @SourceSystem
    )
    BEGIN
        RAISERROR('Transaction with this reference already exists.', 16, 1);
        RETURN;
    END

    BEGIN TRANSACTION;
    BEGIN TRY
        IF (SELECT Balance FROM Accounts WHERE Id = @DebitAccountId) < @Amount
        BEGIN
            RAISERROR('Insufficient funds in debit account.', 16, 1);
            ROLLBACK TRANSACTION;
            RETURN;
        END

        DECLARE @DebitEntryId INT;
        INSERT INTO LedgerEntries (
            ReferenceId, SourceSystem, AccountId, EntryType, Amount,
            CurrencyCode, Description, TransactionTypeId
        )
        VALUES (
            @ReferenceId, @SourceSystem, @DebitAccountId, 'debit', @Amount,
            @CurrencyCode, @Description, @TransactionTypeId
        );
        SET @DebitEntryId = SCOPE_IDENTITY();

        DECLARE @CreditEntryId INT;
        INSERT INTO LedgerEntries (
            ReferenceId, SourceSystem, AccountId, EntryType, Amount,
            CurrencyCode, Description, TransactionTypeId
        )
        VALUES (
            @ReferenceId, @SourceSystem, @CreditAccountId, 'credit', @Amount,
            @CurrencyCode, @Description, @TransactionTypeId
        );
        SET @CreditEntryId = SCOPE_IDENTITY();

        UPDATE Accounts SET Balance = Balance - @Amount WHERE Id = @DebitAccountId;
        UPDATE Accounts SET Balance = Balance + @Amount WHERE Id = @CreditAccountId;

        INSERT INTO AuditLogs (EntityType, EntityId, Action, Data)
        VALUES ('LedgerEntry', @DebitEntryId, 'Insert', 'Debit entry posted');

        INSERT INTO AuditLogs (EntityType, EntityId, Action, Data)
        VALUES ('LedgerEntry', @CreditEntryId, 'Insert', 'Credit entry posted');

        COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION;
        THROW;
    END CATCH
END;

post_credit
sql
CREATE PROCEDURE post_credit
    @ReferenceId NVARCHAR(100),
    @SourceSystem NVARCHAR(100),
    @CreditAccountId UNIQUEIDENTIFIER,
    @DebitAccountId UNIQUEIDENTIFIER,
    @Amount DECIMAL(18, 2),
    @CurrencyCode CHAR(3),
    @Description NVARCHAR(255),
    @TransactionTypeId INT
AS
BEGIN
    SET NOCOUNT ON;

    IF EXISTS (
        SELECT 1 FROM LedgerEntries
        WHERE ReferenceId = @ReferenceId AND SourceSystem = @SourceSystem
    )
    BEGIN
        RAISERROR('Transaction with this reference already exists.', 16, 1);
        RETURN;
    END

    BEGIN TRANSACTION;
    BEGIN TRY
        IF (SELECT Balance FROM Accounts WHERE Id = @CreditAccountId) < @Amount
        BEGIN
            RAISERROR('Insufficient funds in credit account.', 16, 1);
            ROLLBACK TRANSACTION;
            RETURN;
        END

        DECLARE @CreditEntryId INT;
        INSERT INTO LedgerEntries (
            ReferenceId, SourceSystem, AccountId, EntryType, Amount,
            CurrencyCode, Description, TransactionTypeId
        )
        VALUES (
            @ReferenceId, @SourceSystem, @CreditAccountId, 'credit', @Amount,
            @CurrencyCode, @Description, @TransactionTypeId
        );
        SET @CreditEntryId = SCOPE_IDENTITY();

        DECLARE @DebitEntryId INT;
        INSERT INTO LedgerEntries (
            ReferenceId, SourceSystem, AccountId, EntryType, Amount,
            CurrencyCode, Description, TransactionTypeId
        )
        VALUES (
            @ReferenceId, @SourceSystem, @DebitAccountId, 'debit', @Amount,
            @CurrencyCode, @Description, @TransactionTypeId
        );
        SET @DebitEntryId = SCOPE_IDENTITY();

        UPDATE Accounts SET Balance = Balance - @Amount WHERE Id = @CreditAccountId;
        UPDATE Accounts SET Balance = Balance + @Amount WHERE Id = @DebitAccountId;

        INSERT INTO AuditLogs (EntityType, EntityId, Action, Data)
        VALUES ('LedgerEntry', @CreditEntryId, 'Insert', 'Credit entry posted');

        INSERT INTO AuditLogs (EntityType, EntityId, Action, Data)
        VALUES ('LedgerEntry', @DebitEntryId, 'Insert', 'Debit entry posted');

        COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION;
        THROW;
    END CATCH
END;

Appendix C. Balancing the ledger
To find an unbalanced account for the specific date range, we can use the following query:
sql
DECLARE @StartDate DATETIME2 = '2025-08-04 00:00:00';
DECLARE @EndDate DATETIME2 = '2025-08-04 23:59:59.999';

SELECT 
    a.Id AS AccountId,
    a.Name,
    a.CurrencyCode,
    a.Balance AS RecordedBalance,
    ISNULL(SUM(CASE WHEN le.EntryType = 'credit' THEN le.Amount ELSE 0 END), 0) -
    ISNULL(SUM(CASE WHEN le.EntryType = 'debit' THEN le.Amount ELSE 0 END), 0) AS CalculatedBalance,
    a.Balance - (
        ISNULL(SUM(CASE WHEN le.EntryType = 'credit' THEN le.Amount ELSE 0 END), 0) -
        ISNULL(SUM(CASE WHEN le.EntryType = 'debit' THEN le.Amount ELSE 0 END), 0)
    ) AS BalanceDifference
FROM Accounts a
LEFT JOIN LedgerEntries le ON le.AccountId = a.Id
    AND le.CreatedAt BETWEEN @StartDate AND @EndDate
GROUP BY a.Id, a.Name, a.CurrencyCode, a.Balance
HAVING ABS(a.Balance - (
    ISNULL(SUM(CASE WHEN le.EntryType = 'credit' THEN le.Amount ELSE 0 END), 0) -
    ISNULL(SUM(CASE WHEN le.EntryType = 'debit' THEN le.Amount ELSE 0 END), 0)
)) > 0.01;

To verify that the ledger is balanced for the specific date range, we need to ensure that the sum of all debit entries equals the sum of all credit entries, ideally grouped by currency (in our case this might not matter, because everything will be in the USD for now).
sql
DECLARE @StartDate DATETIME2 = '2025-08-04 00:00:00';
DECLARE @EndDate DATETIME2 = '2025-08-04 23:59:59.999';

SELECT
    SUM(CASE WHEN EntryType = 'debit' THEN Amount ELSE 0 END) AS TotalDebits,
    SUM(CASE WHEN EntryType = 'credit' THEN Amount ELSE 0 END) AS TotalCredits,
    SUM(CASE WHEN EntryType = 'debit' THEN Amount ELSE 0 END) -
    SUM(CASE WHEN EntryType = 'credit' THEN Amount ELSE 0 END) AS Difference
FROM LedgerEntries
WHERE CreatedAt BETWEEN @StartDate AND @EndDate
HAVING ABS(
    SUM(CASE WHEN EntryType = 'debit' THEN Amount ELSE 0 END) -
    SUM(CASE WHEN EntryType = 'credit' THEN Amount ELSE 0 END)
) > 0.01;

To showcase that, let’s review the two cases and what would be the result sets here.
Balanced ledger example
LedgerEntries table:
Id
ReferenceId
SourceSystem
AccountId
EntryType
Amount
CurrencyCode
Description
TransactionTypeId
CreatedAt
1  
REF001      
SYS1         
A1        
debit     
100.00  
USD           
Payment to vendor 
1                 
2025-08-01 10:00:00 
2  
REF001      
SYS1         
A2        
credit    
100.00  
USD           
Payment received  
1                 
2025-08-01 10:00:01 
3  
REF002      
SYS1         
A1        
debit     
50.00   
USD           
Subscription fee  
2                 
2025-08-02 09:00:00 
4  
REF002      
SYS1         
A3        
credit    
50.00   
USD           
Subscription paid 
2                 
2025-08-02 09:00:01 
Accounts table:
AccountId
Name
CurrencyCode
RecordedBalance
A1
Account A
USD
150.00
A2
Account B
USD
100.00
A3
Account C
USD
50.00
Unbalanced query result
wide
| AccountId | Name     | CurrencyCode | RecordedBalance | CalculatedBalance | BalanceDifference |
|-----------|----------|---------------|------------------|--------------------|-------------------|
| A1        | Account A| USD           | 150.00           | 150.00             | 0.00              |
| A2        | Account B| USD           | 100.00           | 100.00             | 0.00              |
| A3        | Account C| USD           | 50.00            | 50.00              | 0.00              |

Ledger balance check result:
| TotalDebits | TotalCredits | Difference |
|-------------|--------------|------------|
| 150.00      | 150.00       | 0.00       |

Unbalanced LedgerEntries table:
Id
ReferenceId
SourceSystem
AccountId
EntryType
Amount
CurrencyCode
Description
TransactionTypeId
CreatedAt
5  
REF003      
SYS1         
A1        
debit     
200.00  
USD           
Refund issued     
3                 
2025-08-03 11:00:00 
6  
REF003      
SYS1         
A2        
credit    
150.00  
USD           
Refund received   
3                 
2025-08-03 11:00:01 
Accounts table:
AccountId
Name
CurrencyCode
Balance
A1
Account A
USD
100.00
A2
Account B
USD
100.00
Unbalanced query result:
| AccountId | Name     | CurrencyCode | RecordedBalance | CalculatedBalance | BalanceDifference |
|-----------|----------|---------------|------------------|--------------------|-------------------|
| A1        | Account A| USD           | 100.00           | -200.00            | -300.00           |
| A2        | Account B| USD           | 100.00           | 150.00             | 50.00             |

Ledger balance check result:
| TotalDebits | TotalCredits | Difference |
|-------------|--------------|------------|
| 200.00      | 150.00       | 50.00      |

 URL:/spaces/EA/pages/4526014529/Ledger+service+proposal