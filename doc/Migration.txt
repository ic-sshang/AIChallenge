 Overview
The New Payer Experience is a reimagined standalone user experience of an existing product’s, MyIIS, one-time payment workflow.   The business logic in MyIIS is distributed between WebForms ASPX code behind pages and a class library IC.Common.  Migrating the business logic to use in a .Net 6 application presents a few challenges in its current state.  MyIIS business logic exposes functionality via static methods with singletons underneath, is coupled to 
ASP.Net
 infrastructure (UI controls, HttpContext, Session, etc…), and is based on .Net Full for Windows.  Please read the 
.Net project structure page
 before you begin.
Identify, T-Shirt Size, and Classify
For each feature / function identify the legacy business logic code.   Assess the feasibility of components used.  Are there any components that can not be used in .Net 6 or refactored away?  T-Shirt size (Small, Medium, Large) the level of effort to extract, port, and refactor the code to .Net 6.  Classify the business logic risk as it relates to impact on the product functionality.  Ask yourself if a refactor mistake would prevent functionality and fail fast or could it go undetected and result in a loss in revenue or damage for the business or the customer.
Rewrite Legacy Code In .Net 6
Use this strategy when the impact risk is low and the amount of code is small.  This is the ideal path and will incur little to no technical debit and result in new code that can be used by .Net 6 applications and unit tested going forward.  Copy the targeted code from the MyIIS solution into your business class library.  Begin by breaking down the code into business service classes by single responsibility.  Remember that each service should implement an interface so that services can be passed as dependencies to other services.   Breaking the code down should not impact the overall business logic behavior and yield a better structure of the business logic going forward.  When you run into code that uses non-standard .Net 6 language types ( for example http clients, third party components, UI controls, or data access components ) stop and assess.  If the code references a UI control for its values then this should likely be refactored as an business model input and output to your business service.  If the code is using a data access component, third party component, or a infrastructure component (HTTP client, etc…) stub out a infrastructure interface in your business class library with a method using business models as the inputs and outputs that abstracts out the infrastructure functionality and can later be mocked in unit tests.   This interface will now be passed to your business service implementation as a dependency in its constructor.  Implement this interface in a class in a infrastructure class library by removing the infrastructure code from your business code and porting it into your infrastructure implementation.  The business service should now be calling the new method on your infrastructure interface where the infrastructure code used to be.  Unit tests targeting the business service will mock any infrastructure interface dependencies.
Facade SOAP API 
Use this strategy when there are components that can not be migrated, impact risk is high, or the amount of code is large.  This will incur some technical debit and result in new code that that is coupled to the SOAP API.  However, this approach will isolate code that can not be migrated now into easy identifiable input/output contracts to be refactored later.  When you run into code that can not be migrated create a SOAP API and operation in MyIIS that exposes the input and output in the operation request and response.  Extract the business logic from the ASPX code behind and / or use IC.Common in the API operation code.  The .Net 6 authentication scheme is using a header JWT bearer token.  A JWT header value will also be used in the SOAP API to allow for authentication passthrough and to establish trust.  The SOAP API must validate the JWT and any required claims.  In the .Net 6 solution stub out a infrastructure interface in your business class library with a method using business models as the inputs and outputs that abstracts out the SOAP API operation client functionality, request, and response models and can later be mocked in unit tests.    This interface will be passed to your business service implementations as a dependency in their constructors.  Implement this interface in a class in a infrastructure class library by creating the required SOAP client operation API call.  Unit tests targeting business services will mock the infrastructure interface dependency.  Integration tests can target this infrastructure implementation to test the encapsulated SOAP API and its various inputs and outputs.
Logging
As we make our shift to Kubernetes and .Net 6 the containers we build should run a single .Net process.  The process should write to the STDOUT and STDERR (Console.WriteLine and Console.Error.WriteLine) streams for all logging.  .Net 6 provides logging infrastructure that handles this for us by configuring the process to use the ConsoleLoggerProvider and the ILogger interface.  The data collected from these streams are piped to the container logs on the host and will be shipped to our aggregated logging system of choice (as of this writing that is New Relic).
 Tips and tricks 
Static methods should be reserved for factory and helpers where all of the dependencies are parameters.
 URL:/spaces/EN/pages/2517270529/Migration