2
1
0
0
4579360918
4568645933
1
Kount360.drawio
1
1
https://invoicecloud.atlassian.net/wiki
Kount360.drawio
0
1911
473.5
General Documentation Link: 
https://developer.kount.com/hc/en-us/articles/14474979202068-Payments-Fraud-v2-0-Integration-Guide
 
Order API Documentation Link: 
https://api.kount.com/commerce/help#operation/CommerceOrchestrator_UpdateOrder
 
DDC API Web Documentation Link: 
https://developer.kount.com/hc/en-us/p/integration-builder?choice=WEB
 
Implementation type:
 Library (NuGet) — 
IC.FraudDetection
 (
netstandard2.0
)
Stack:
 MyIIS (Web, .NET Framework 4.8) + CTP (Server, .NET Framework 4.8) + shared package 
IC.FraudDetection
Scope:
 Orders API (pre‑authorization) first; 
DDC later
; 
decision upsert later
Processor:
 Synchronous (inline patch)
Persistence:
CTP:
 no persistence of Kount IDs (kept in memory only for same‑request inline Patch).
FraudDecisionHistory (DB):
 present for 
lookup
; 
Upsert is disabled in current phases
 (enabled in a later phase after review).
1) Architecture at a glance
MyIIS (current):
 No DDC yet. MyIIS posts order/payment info to CTP (no 
deviceSessionId
).
CTP (current flow):
Compute 
CreditCardHashValue
 in CTP from 
PAN + MMYY
 (see §4.1).
DB lookup first
 in 
FraudDecisionHistory
 by 
(Merchant, Channel, CreditCardHashValue)
Hit:
 Return stored 
Outcome/Score
, mark 
FromHistory=true
. 
Skip Kount
 and 
skip Patch
 (no 
orderId
).
Miss:
 Call Kount 
Evaluate
 (pre‑auth). Proceed to processor, then 
Patch
 inline (no rescore).
Upsert
 of fresh decisions is 
disabled
 for now (enable in a later phase).
Processor authorization
 (synchronous).
Inline Patch:
 
PATCH /commerce/v2/orders/{orderId}
 
only
 when 
FromHistory=false
 (i.e., the decision came from Kount for this order).
MyIIS (later):
 Add 
Device Data Collector (DDC)
 in the browser and include 
deviceSessionId
 to link device data to the Kount order.
Key principles
DDC runs 
only in the browser
; server never runs the Web Client SDK.
deviceSessionId
 is 
optional now
, enabled when DDC is added later.
For 
history hits
, there is 
no Kount 
orderId
for this order → 
skip Patch
.
2) Environments & credentials)
API base:
Sandbox 
https://api-sandbox.kount.com
 
Production 
https://api.kount.com
Orders endpoints:
POST
 
/commerce/v2/orders
 (query: 
riskInquiry
, optional 
excludeDevice
)
PATCH
 
/commerce/v2/orders/{orderId}
PATCH
 
/commerce/v2/orders:batchUpdateReversals
 (batch chargeback/refund metadata)
GET
 
/commerce/v2/orders/{orderId}
 (support/forensics) 
Auth:
 OAuth2 client‑credentials (
k1_integration_api
) via tenant token URL; token is short‑lived (20 minutes); cache/refresh about 5 minutes early.
Headers:
 Capture 
X‑Correlation‑Id
 from 200/400/500 responses for troubleshooting.
Secrets:
 Store in vault; never log PAN/PII or OAuth secrets
3) Shared library — 
IC.FraudDetection
 (netstandard2.0)
Single target so .NET 4.8 apps can consume now; .NET 6/7/8+ later with the same package.
3.1 Public DTOs (namespace 
IC.FraudDetection
, folder 
Models/
)
wide
760
public class FraudOrder {
  public string MerchantOrderId { get; set; } = "";
  public string Channel { get; set; } = "";
  public string? DeviceSessionId { get; set; }            // set once DDC is live
  public DateTimeOffset CreationDateTimeUtc { get; set; }
  public string? UserIp { get; set; }
  public List<FraudItem> Items { get; set; } = new();
  public FraudPayment Payment { get; set; } = new();
  public string Currency { get; set; } = "";
  public long OrderTotal { get; set; }                     // integer, minor units
  public Dictionary<string, object>? CustomFields { get; set; }  // optional (keys ≤ 32, primitive values)
}

public class FraudItem {
  public string Name { get; set; } = "";
  public int Quantity { get; set; }
  public long PriceMinor { get; set; }                     // integer, minor units
}

public class FraudPayment {
  public string Type { get; set; } = "";                   // "TOKEN","CREDIT_CARD",...
  public string? Token { get; set; }                       // only if using Kount salted SHA‑256
  public string? Bin { get; set; }
  public string? Last4 { get; set; }
  public string? CreditCardHashValue { get; set; }         // SHA‑512 lower‑hex of "PAN|MMYY"; never sent to Kount
}

public enum FraudOutcome { Approve, Review, Decline, Error }

public class FraudDecision {
  public FraudOutcome Outcome { get; set; }
  public double? Score { get; set; }                       // omniscore can be fractional
  public string? VendorOrderId { get; set; }               // Kount orderId; null on FromHistory
  public bool DeviceLinked { get; set; }
  public string? PolicyDecision { get; set; }
  public string? Reason { get; set; }                      // on Outcome=Error
  public bool FromHistory { get; set; }
}

public class AuthorizationUpdate {
  // Must be UPPERCASE: APPROVED | DECLINED | ERROR | UNKNOWN
  public string AuthResult { get; set; } = "";
  // CVV must be MATCH | NO_MATCH | UNKNOWN ; AVS uses single-letter codes (A/Y/…)
  public string? AvsStatus { get; set; }
  public string? CvvStatus { get; set; }
  // Present for future use; not included in PATCH payload per current schema
  public string? ProcessorAuthCode { get; set; }
  public string? ProcessorTransactionId { get; set; }
  public string? TransactionId { get; set; }
}

3.2 Public interfaces (Abstractions)
wide
760
public interface IFraudDetectionClient {
  Task<FraudDecision> EvaluatePreAuthAsync(FraudOrder order, bool riskInquiry = true, CancellationToken ct = default);
  Task PatchAuthorizationAsync(string vendorOrderId, AuthorizationUpdate update, CancellationToken ct = default);
}

public interface IFraudDecisionRepository {
  Task<FraudDecision?> TryGetByCardHashAsync(string merchant, string channel, string cardHashHex, CancellationToken ct);
  Task UpsertAsync(string merchant, string channel, string cardHashHex, FraudOutcome outcome, int score, DateTimeOffset nowUtc, CancellationToken ct);
}
Note:
 The repository is wired only for 
lookup
 in current phases; 
Upsert
 stays disabled.
3.3 Internal flow (Evaluate & Patch)
Evaluate:
If 
CreditCardHashValue
 provided → repository 
TryGet
.
Hit:
 return (Outcome/Score, 
FromHistory=true
, 
VendorOrderId=null
).
Miss:
 call 
Kount Evaluate
, parse decision/score; 
do not upsert
 yet (until later phase).
If no hash provided → call Kount directly (no DB read).
Patch:
 only when 
FromHistory=false
 (fresh Kount call for this order).
Resilience/auth:
 single 
HttpClient
, ~5s timeout, retry 5xx/timeouts (no retry on 4xx); OAuth client‑credentials with in‑memory token cache and early refresh.
4) Orders API on CTP (pre‑authorization, synchronous + inline patch)
4.1 
CreditCardHashValue
 in CTP (high‑level)
Input:
 PAN and expiration 
MMYY
.
Normalize PAN:
 digits only.
Build string:
 
PAN_DIGITS + "|" + MMYY
 (note the 
|
 delimiter).
Hash:
 compute 
SHA‑512
 over the 
ASCII
 bytes of that string.
Output:
 represent as 
lower‑case hex
 (128 chars).
Privacy:
 never log PAN, MMYY, or the preimage string; store/transmit the hex hash only.
4.2 Evaluate → Processor → Patch
Evaluate (pre‑auth):
 call 
EvaluatePreAuthAsync
 with 
FraudOrder.Payment.CreditCardHashValue
.
FromHistory=true:
 reused prior decision from DB; 
do not call Kount
.
FromHistory=false:
 the library called Kount and returned fresh decision (no upsert yet).
Processor (synchronous):
 run the processor authorization.
Patch (post‑auth):
 
only
 when 
FromHistory=false
 (you have a Kount 
VendorOrderId
); call 
inline
 after processor returns.
Enforcement:
 governed by 
Kount.EnforceDecision
 (default 
false
). If 
Decline
 and enforcement is 
true
, 
do not
 call processor or Patch.
5) Wire‑level compliance (adapter responsibilities)
Amounts as strings:
 Convert 
OrderTotal
, 
Subtotal
, item prices, shipping/tax to 
stringified uint64
 in JSON; 
currency
 is on each 
transaction
 (
transactions[*].currency
).
Auth result casing:
 Uppercase 
authResult
 in Patch; map CVV to 
MATCH/NO_MATCH/UNKNOWN
; AVS remains a letter code.
Minimal Patch:
 Only 
authorizationStatus.authResult
 and 
.verificationResponse{ cvvStatus, avsStatus }
 (plus 
transactionId
). Do 
not
 include dateTime, decline/processor codes, or ARN in the 
PATCH
 body.
Omniscore:
 Parse 
riskInquiry.omniscore
 as 
double
 (fractional is possible).
Correlation:
 Read/log 
X‑Correlation‑Id
 from responses (200/400/500).
Optional param:
 
excludeDevice
 exists for call‑center/kiosk (not used currently).
Payment token:
 If you 
don’t
 have Kount’s salted SHA‑256 tokenization, 
omit
 
paymentToken
 and send 
bin
 + 
last4
 using the correct 
payment.type
 (e.g., 
CREDIT_CARD
).
(Optional, not in current flow)
:
Evaluate POST
 can include 
transactions[].authorizationStatus
 (post‑auth pattern).
PATCH
 may include 
riskInquiry
 override 
{ decision: "APPROVED"|"DECLINED", reasonCode }
 if merchant policy needs it.
6) JSON payloads (Kount)
6.1 Evaluate (pre‑auth) — minimal example
wide
760
{
  "merchantOrderId": "ORDER-12345",
  "channel": "DEFAULT",
  "creationDateTime": "2025-08-15T19:22:11Z",
  "userIp": "203.0.113.45",
  "transactions": [
    {
      "merchantTransactionId": "TXN-12345",
      "processor": "CHASE",
      "payment": {
        "type": "CREDIT_CARD",
        "bin": "411111",
        "last4": "1111"
      },
      "subtotal": "2999",
      "orderTotal": "2999",
      "currency": "USD"
    }
  ],
  "customFields": {
    "paymentSource": 1,
    "paymentOrigin": 2,
    "termID": 44,
    "loginID": 12345,
    "userID": 9001,
    "billerID": 3451
  }
}


CreditCardHashValue
 is 
internal only
; never sent to Kount.
6.2 Patch (post‑auth) — minimal example
wide
760
{
  "transactions": [
    {
      "transactionId": "TXN-12345",
      "authorizationStatus": {
        "authResult": "APPROVED",
        "verificationResponse": {
          "avsStatus": "Y",
          "cvvStatus": "MATCH"
        }
      }
    }
  ]
}
7) Library ↔ Kount JSON mapping
Evaluate (POST)
Normalized (
FraudOrder
)
Kount JSON path
MerchantOrderId
merchantOrderId
Channel
channel
DeviceSessionId
 (future DDC)
deviceSessionId
CreationDateTimeUtc
creationDateTime
 (RFC‑3339)
UserIp
userIp
OrderTotal
transactions[0].orderTotal
Payment.Token
transactions[0].payment.paymentToken
Payment.Type
transactions[0].payment.type
Payment.Bin
 / 
Payment.Last4
transactions[0].payment.bin
 / 
...last4
Payment.CreditCardHashValue
internal only; not sent to Kount
Patch (PATCH)
Normalized (
AuthorizationUpdate
)
Kount JSON path
AuthResult
 
"APPROVED"/"DECLINED"
transactions[0].authorizationStatus.authResult
 (
"Approved"/"Declined"
)
AvsStatus
transactions[0].authorizationStatus.verificationResponse.avsStatus
CvvStatus
transactions[0].authorizationStatus.verificationResponse.cvvStatus
ProcessorAuthCode
transactions[0].authorizationStatus.processorAuthCode
ProcessorTransactionId
transactions[0].authorizationStatus.processorTransactionId
TransactionId
 (optional)
include if present
7) Library ↔ Kount mapping (selected)
Evaluate → POST 
/v2/orders
FraudOrder.MerchantOrderId
 → 
merchantOrderId
FraudOrder.Channel
 → 
channel
FraudOrder.DeviceSessionId
 → 
deviceSessionId
 (when DDC live)
CreationDateTimeUtc
 → 
creationDateTime
 (RFC‑3339)
UserIp
 → 
userIp
OrderTotal
 (double) → 
transactions[0].orderTotal
 (
string
)
Currency
 → 
transactions[0].currency
Payment.Token
 → 
transactions[0].payment.paymentToken
 (only if Kount salted token available)
Payment.Type
 → 
transactions[0].payment.type
Payment.Bin/Last4
 → 
transactions[0].payment.bin/last4
CustomFields
 → 
customFields
 (keys ≤ 32 chars; primitives only).
Patch → PATCH 
/v2/orders/{orderId}
AuthorizationUpdate.AuthResult
 (
UPPERCASE
) → 
transactions[0].authorizationStatus.authResult
AuthorizationUpdate.AvsStatus
 → 
...verificationResponse.avsStatus
AuthorizationUpdate.CvvStatus
 (map to 
MATCH/NO_MATCH/UNKNOWN
) → 
...verificationResponse.cvvStatus
Other 
AuthorizationUpdate
 properties are 
ignored
 by Patch (kept for future use).
Evaluate response → 
FraudDecision
order.riskInquiry.decision
 → 
Outcome
 (APPROVE→Approve, REVIEW→Review, DECLINE→Decline)
order.riskInquiry.omniscore
 (string/number) → 
Score
 (
Integer
)
order.riskInquiry.device.id
 not null → 
DeviceLinked=true
. 
8) Configuration (CTP & Library)
CTP app settings
wide
760
<add key="Kount.Enabled" value="true" />
<add key="Kount.EnforceDecision" value="false" />  <!-- observe-only default -->
<add key="Kount.UseSandbox" value="true" />
<add key="Kount.ApiBaseUri" value="https://api-sandbox.kount.com" />
<add key="Kount.TokenUri" value="https://login.kount.com/.../v1/token" />
<add key="Kount.ClientId" value="" />
<add key="Kount.ApiKeyBasic" value="" />
<add key="Kount.Channel" value="DEFAULT" />
<add key="Kount.HttpTimeoutSeconds" value="5" />

FraudDecisionHistory (DB)
wide
760
<add key="FraudDecisionHistory.ConnectionString" value="Name=IC_CommerceDb" />
<add key="FraudDecisionHistory.LookupEnabled" value="true" />
<add key="FraudDecisionHistory.UpsertEnabled" value="false" />
<add key="FraudDecisionHistory.RefreshDays" value="TBD" />
<add key="FraudDecisionHistory.HashAlgorithm" value="SHA-512" />

(DDC keys added later when that phase starts.)
9) 
Custom Fields
 — what to send from your payments data
Kount’s 
customFields
 object accepts 
primitive
 values only (string/number/boolean/RFC‑3339 date), with 
key length ≤ 32
 chars—no nested objects/arrays. Use them for 
merchant‑specific context
 that helps explain risk (channel/source, operational flags, internal references). 
Kount API
9.1 What you have (from 
payments.csv
)
From your sample file, the dataset includes (among others):
PaymentID, InvoiceID, CustomerID, BillerID, InvoiceNumber, PaymentAmount, PaymentDescription, TransactionTypeID, PaymentDate, PaymentReference, PaymentMessage, SecureCardnumber, Cardnumber, ExpMonth, ExpYear, AVSCode, CVVCode, SecureAccountNumber, Checking, BankAccountTypeID, RTE, AccountNumber, CheckNumber, Approved, CloudPortals, Offline, WSReportID, BillerReference, ConvenienceFee, PaymentSourceID, RemoteIP, UserID, PaymentIndex, DateRecAdded, UTCDateRecAdded, TermID, ReceiptGUID, RejectReference, EmailAddress, Paperless, TraceNumber, CreditPaymentID, LoginID, PaymentMethodOriginID
.
(I filtered out PCI/PII when building recommendations below.)
9.2 Recommended 
customFields
 (safe & useful)
customFields key
Source column
Type
Example
Why it helps
psrc
PaymentSourceID
number
1
Capture in‑house channel taxonomy (e.g., web/app/csr).
pmt_origin
PaymentMethodOriginID
number
2
Distinguish origin within channel (browser vs. mobile vs. IVR).
term_id
TermID
number
44
Terminal/host node useful for clustering risk.
login_id
LoginID
number
12345
Logged‑in user identifier (internal).
csr_user_id
UserID
number
9001
CSR/agent performing the action (if any).
biller_id
BillerID
number
3451
Segment performance and fraud by biller.
is_portal
CloudPortals
boolean
true
Channel nuance.
Already covered elsewhere (don’t duplicate):
RemoteIP
 → 
use 
userIp
 at top level (not a custom field).
PaymentAmount
/tax/shipping → 
transactions
 section (as 
strings
).
PaymentDate
 → 
creationDateTime
 (ISO).
Do NOT send (PCI/PII or redundant):
Cardnumber
, 
SecureCardnumber
, 
ExpMonth
, 
ExpYear
, 
CVVCode
 (PCI).
Bank account fields: 
AccountNumber
, 
SecureAccountNumber
, 
RTE
, 
CheckNumber
, 
Checking
, 
BankAccountTypeID
 (sensitive).
Customer PII: 
CustomerName
, 
EmailAddress
, 
Address
, 
City
, 
State
, 
Zip
 (unless you elect to populate Kount’s 
billedPerson
/
shipping
 objects with proper governance).
TraceNumber
 (potentially sensitive/regulatory).
9.3 Example build (adapter)
Conceptually:
wide
760
var cf = new Dictionary<string, object>();
cf["psrc"] = row.PaymentSourceID;
cf["pmt_origin"] = row.PaymentMethodOriginID;
cf["term_id"] = row.TermID;
cf["login_id"] = row.LoginID;
cf["csr_user_id"] = row.UserID;
cf["biller_id"] = row.BillerID;
cf["is_portal"] = row.CloudPortals == 1;
order.CustomFields = cf;

Keep keys ≤ 32 chars; values must be primitives/dates; omit null/empty values.
10) Database schema — 
FraudDecisionHistory
 (SQL Server example)
Store the SHA‑512 output as 
lower‑case hex
 → 
varchar(128)
.
wide
760
CREATE TABLE dbo.FraudDecisionHistory (
  Merchant              nvarchar(64)  NOT NULL,
  Channel               nvarchar(64)  NOT NULL,
  CardHashHex           varchar(128)  NOT NULL,  -- lower-case hex of SHA-512("PAN_DIGITS|MMYY")
  Outcome               varchar(10)   NOT NULL,  -- Approve | Review | Decline
  Score                 int           NOT NULL,  -- Omniscore
  FirstSeenUtc          datetime2     NOT NULL DEFAULT (sysutcdatetime()),
  LastSeenUtc           datetime2     NOT NULL DEFAULT (sysutcdatetime()),
  HashAlgorithm         varchar(16)   NOT NULL DEFAULT ('SHA-512'),
  CONSTRAINT PK_FraudDecisionHistory PRIMARY KEY (Merchant, Channel, CardHashHex)
);
GO
CREATE INDEX IX_FraudDecisionHistory_LastSeen ON dbo.FraudDecisionHistory (LastSeenUtc DESC);

Current phases:
 table supports 
lookup
 only.
Later phase:
 enable 
Upsert
 (insert on miss / update 
LastSeenUtc
 on hit) after you finalize refresh policy.
11) Model changes (CTP)
Request
 (add the hash; DDC later)
wide
760
' CloudTransactionProcessingSOAP/Models/Requests/IC_CNP_Sale_Request.vb
Public Property CreditCardHashValue As String = ""       ' lower-case hex SHA-512("PAN_DIGITS|MMYY")
Public Property KountDeviceSessionId As String = ""      ' (future) set once DDC is live

Response
 (surface decision, score, and source)
wide
760
' CloudTransactionProcessingSOAP/Models/Responses/IC_CNP_Sale_Response.vb
Public Property KountOrderId As String = ""              ' empty when FromHistory=true
Public Property KountDecision As String = ""
Public Property KountOmniscore As Double = 0
Public Property KountFromHistory As Boolean = False

12) Error handling, retries, idempotency
Evaluate ordering:
 DB lookup → (Miss) Kount Evaluate → return decision 
(Upsert disabled for now)
.
Patch:
 only for 
FromHistory=false
 decisions; retry 5xx/timeouts; 
no retry
 on 4xx.
DB failure policy:
Lookup failure ⇒ 
fail‑open
 to Kount Evaluate (log repository error).
Token caching:
 in memory; refresh before expiry.
Idempotency:
 de‑dupe Evaluate within a request; DB key = 
(Merchant, Channel, CardHashHex)
 for future Upsert use.
11) Rollout plan (final sequence)
Phase 1 — Observe‑only (no DDC; Upsert OFF):
Evaluate with 
DB‑first lookup
.
Hit:
 return stored decision; 
skip Kount & Patch
.
Miss:
 call Kount; 
Patch inline
 after processor; 
do not
 upsert yet.
Kount.EnforceDecision = false
. Capture baselines (decision mix, Omniscore, history hit rate, latency, Patch health).
Phase 2 — Monitoring (observe‑only):
Dashboards & alerts; refine thresholds. Upsert and DDC remain 
out of scope
.
Phase 3 — Enable Enforcement (pilot → expand):
Turn 
Kount.EnforceDecision = true
 for a low‑risk pilot segment; monitor KPIs; be ready to toggle off.
If stable, expand enforcement coverage. 
DDC still not enabled; Upsert still OFF.
Phase 4 — Add DDC:
Integrate DDC on MyIIS; begin sending 
deviceSessionId
; validate device linkage. 
(Still Upsert OFF.)
Phase 5 — Enable Upsert:
Define 
RefreshDays
 policy; enable 
FraudDecisionHistory.UpsertEnabled = true
.
Begin persisting new decisions and optionally refreshing stale rows.
12) Minimal call‑site sketch (CTP, VB — synchronous + inline patch, current scope)
wide
760
' 1) Compute CreditCardHashValue (PAN + MMYY) → lower-case hex SHA-512
Dim cardHashHex As String = BuildCreditCardHashValue(rawPan, expMonth, expYear) ' per §4.1

' 2) Build FraudOrder
order.Payment.CreditCardHashValue = cardHashHex

' 3) Evaluate (library does DB-first; Upsert is disabled for now)
Dim decision = client.EvaluatePreAuthAsync(order, riskInquiry:=True).Result

' 4) Surface to response
res.KountOrderId = If(decision.FromHistory, "", decision.VendorOrderId)
res.KountDecision = decision.Outcome.ToString()
res.KountOmniscore = If(decision.Score.HasValue, decision.Score.Value, 0)
res.KountFromHistory = decision.FromHistory

' 5) Optional enforcement
If Settings.KountEnforceDecision AndAlso decision.Outcome = FraudOutcome.Decline Then
  res.ApprovalIndicator = False
  Return
End If

' 6) Processor authorization (synchronous) → set approval + AVS/CVV/AuthCode/TxnId

' 7) Inline Patch (only when Evaluate came from Kount for THIS order)
If Not decision.FromHistory AndAlso Not String.IsNullOrEmpty(res.KountOrderId) Then
  Dim patch = New AuthorizationUpdate(
    AuthResult := If(res.ApprovalIndicator, "APPROVED", "DECLINED"),
    AvsStatus := misc.AvsStatus,
    CvvStatus := misc.CvvStatus,
    ProcessorAuthCode := misc.ProcessorAuthCode,
    ProcessorTransactionId := misc.ProcessorTxnId
  )
  client.PatchAuthorizationAsync(res.KountOrderId, patch, CancellationToken.None).Wait()
End If

13) Jira roadmap
WT-117
2278e126-27dc-36c8-aef9-a32d91bc7ad7
System Jira
 
Public DTOs/interfaces; token client; resilience (timeouts/retries); netstandard2.0 NuGet.
WT-118
2278e126-27dc-36c8-aef9-a32d91bc7ad7
System Jira
Kount adapter with OAuth; POST Evaluate; PATCH post‑auth; mapping & unit tests
WT-152
2278e126-27dc-36c8-aef9-a32d91bc7ad7
System Jira
 
Create 
FraudDecisionHistory
 table; implement repository; wire 
TryGet
 into Evaluate.
WT-119
2278e126-27dc-36c8-aef9-a32d91bc7ad7
System Jira
 
Insert Evaluate‑before‑processor and inline Patch (only when non‑history); expose fields on CTP response.
WT-120
2278e126-27dc-36c8-aef9-a32d91bc7ad7
System Jira
Metrics/logs/dashboards for Evaluate outcomes, latencies, Patch success, 
history hit rate
; alerts tuned.
WT-121
2278e126-27dc-36c8-aef9-a32d91bc7ad7
System Jira
 
Feature‑flag on for pilot segment; monitor KPIs; fast rollback; expand when stable.
Future backlog :
WT‑1XX — Add DDC to MyIIS
 (send 
deviceSessionId
).
WT‑1XX — Enable Upsert in FraudDecisionHistory
 (define 
RefreshDays
, turn flag on).
14) Checklist
Publish 
IC.FraudDetection
 (
netstandard2.0
) with 
IFraudDetectionClient
, Kount adapter, and token cache
Wire CTP: 
Evaluate → Processor → Inline Patch
 (observe‑only)
Config in vault; sensible timeouts/retries; redact secrets in logs
Stand up dashboards & alerts; capture baseline
Pilot 
EnforceDecision ON
 for a small segment; monitor & be ready to rollback
Add DDC on MyIIS; begin sending 
deviceSessionId
; verify 
DeviceLinked=true
 on web flows
Enable Upsert
 URL:/spaces/PE/pages/4568645933/Kount+360+Payments+Fraud+v2+Full+Integration+Guide+Library+IC.FraudDetection