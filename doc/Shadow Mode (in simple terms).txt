What Shadow Mode gives us (in plain terms)
Safe, production‑shaped load
: We duplicate live Orbital requests into our new 
ICChasePaymentProcessingAPI
, execute full business logic and DB writes, but 
do not move money
; we return mock Chase responses and clearly audit that the op was shadowed. This lets us validate logic, data, scaling, and ops observability without risk.
Two-stage rollout strategy
:
Phase 1—Shadow Orbital
: clone CTP’s live calls to our API with feature flags, PII stripping, write to Commerce DB, gather telemetry/capacity; all behind a biller‑by‑biller schedule.
Phase 2—Internal Test Module
: enable a Chase PayFac module in CTP for sandbox end‑to‑end tests, gated via platform features per BID; keeps the UI locked until we’re production‑ready.
Phase plan (aligned to MVP / Day‑1 / Day‑90+)
MVP — Regulatory baseline & “all rails” support (with shadow)
Goal:
 be legally live on Chase + keep all other rails usable; prove our new stack in shadow with zero customer impact.
Chase cards (Visa/MC/Disc):
Turn on 
Shadow Mode
 duplication from CTP → ICChasePaymentProcessingAPI for 
sale/void/refund
, using the 
ShadowMode: true
 header. 
Execute business logic + DB ops; bypass external Chase calls or use test endpoints; tag audit records as shadow.
Control via 
platform feature flags
 (Master + shard per BID), with a gradual activation schedule and the ability to “pull the Andon cord” instantly.
Strip/replace PII in cloned traffic; capture latency, DB write counts, pod scaling in New Relic; size the Kubernetes footprint.
Non‑Chase rails (Amex, PayPal, POS)
:
Keep 
existing paths live
 (aggregator/legacy) so every rail is supported at MVP; 
Ensure 
MO# is present
 on all transactions for cross‑rail reconciliation (as we defined in Thread 2).
Ops & evidence
:
Use the 
Internal Test Module
 in CTP (PayFac module gated by platform features) to run 
sandbox
 flows end‑to‑end for staff accounts; block CRM selection until we’re ready.
Exit criteria to Day‑1 (hard gates):
Shadow pass‑rate & error budget met; 
no data integrity deltas
 in DB vs Orbital outcomes.
Sustained load test without pod thrash; 
capacity model
 documented.
Audit logs show 
Real vs Shadow
 clearly; supportability runbooks in place.
Day‑1 — Operational baseline (~20 billers)
Goal:
 light automation + selective 
Real Mode
 cutover for Chase, while other rails remain usable.
Chase Real Mode (limited cohorts):
Flip selected billers to 
Real Mode
 (same handlers, just bypass the shadow branch); retain 
feature‑flag control per BID
 for fast rollback. 
Keep 
shadow enabled in parallel for canary cohorts
 to compare outcomes and latency.
Settlement & funding readiness:
 automated 
nightly settlement ingestion
 for Chase → reconcile by MO# → feed funding job (from Thread 2).
Routing & coexistence:
 Cohort routing keeps 
Amex/PayPal/POS
 on legacy paths; all transactions still carry MO# for unified reporting.
Observability:
 Production dashboards compare 
shadow vs real
 response times, error rates, and DB ops; alerting on drift.
Day‑90+ — Optimization & scale
Goal:
 industrialize multi‑rail orchestration and remove operational friction.
Convert Chase polling to 
event‑driven
 where available; add 
idempotency, circuit breakers, SLOs
 per connector.
Build 
first‑class adapters
 for non‑Chase rails (Amex chosen path, PayPal, etc.) behind a 
provider interface
, keeping our 
handlers stable
.
Expand shadow as a 
permanent regression tool
 (turn on per route during deploys; measure production impact safely).
 URL:/spaces/EA/pages/4598136936/Shadow+Mode+in+simple+terms