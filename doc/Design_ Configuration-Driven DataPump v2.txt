1. Overview
This document outlines the design for making 
DataPump v2
 integration partners fully 
configuration driven
. The goal is to minimize code churn across billers/partners, improve maintainability, and support a 
low-code / no-code
 model where possible.
2. Motivation
Current Issues
Hardcoded endpoints, credentials, and payload fields tied to specific integration partners.
Even small changes (field name, payload structure) require code edits and redeployments.
Retry logic, authentication, and transformation logic are duplicated across integrations.
Objectives
Externalize 
field mappings, endpoints, and retry policies
 into configuration.
Keep 
transformation and validation logic
 in code for consistency and safety.
Support ~30 fields total, with biller-specific subsets.
Optimize for 
performance and cost
 with 
System.Text.Json
 and caching.
3. Design Principles
Configuration-as-Data
All payload structures defined in 
JSON/YAML
 configuration.
Example:
"fields": {
  "accountNumber": "",
  "amount": "",
  "currency": "USD"
}

Strategy Pattern for Value Resolution
Each domain (Payments, Authentication, Autopay, etc.) has a resolver.
Config literals take precedence; empty fields resolved dynamically.
Builder Pattern
PayloadBuilder
 and 
AuthRequestBuilder
 construct dictionaries from config + resolvers.
Factory/Registry
Registry selects the correct resolver for biller/operation.
Supports 
partner-specific overrides
 without rewriting builders.
Retry Policy (Polly)
Config-driven retry with 
exponential backoff
 by default.
Supports per-operation overrides.
4. DTO / Model Strategy
Use a 
generic dictionary DTO
:
Dictionary<string, object?>

Benefits:
No DTO churn.
Fast and flexible.
Ideal for 
low-code configuration
.
5. Runtime Flow
Load config for biller.
Select operation (e.g., 
PostPayment
).
Retrieve correct payload template (approved/unapproved).
Use resolver factory for domain-specific values.
Builder merges:
If literal in config → use literal.
Else → resolve dynamically.
Serialize with 
System.Text.Json
 (
Utf8JsonWriter
 for hot paths).
Apply retry policy (Polly).
Send via 
HttpClient
 (via 
IHttpClientFactory
).
Map response to 
DataPumpResponseBase
.
6. Retry Policy
Default:
 exponential backoff.
Example (limit 3, base 3000ms):
3s → 6s → 12s.
Supports overrides:
Constant delay.
Jitter.
Configurable caps: 
maxWait
, 
maxElapsed
.
Cached per biller + operation.
7. Performance Considerations
Serialization
: Utf8JsonWriter, pooled buffers, omit nulls.
Caching
: Configs, secrets, and retry policies cached per biller.
Validation
: Enforced by code (required fields, ranges).
No Reflection
: Use switch expressions for resolvers.
Transport
: 
IHttpClientFactory
 for pooled connections.
8. Configuration Storage Approaches
Option A — Full JSON per Biller
Example (2002)
json
wide
1800
{
  "integrationType": "Demo",
  "billerId": 2002,

  "behavior": {
    "isAuthentication": true,
    "isRetry": true,
    "isTransformation": false,
    "apiType": "REST"
  },

  "retry": {
    "limit": 4,
    "waitMs": 3000,
    "retryOn": [500, 502, 503, 504]
  },

  "authentication": {
    "tokenUrl": "<SecondaryRTDREndpoint>",
    "endpointType": "POST",
    "apiType": "REST",
    "fields": {
      "grant_type": "client_credentials",
      "client_id": "",
      "client_secret": "",
      "scope": ""
    }
  },

  "aliases": {
    "AcctNum": "AccountNumber"
  },

  "billerPayloads": {
    "payment": {
      "fields": {
        "BillerID": "",
        "PaymentID": "",
        "PaymentAmount": "",
        "CustomerID": "",
        "AccountNumber": "",
        "InvoiceID": "",
        "InvoiceNumber": ""
      }
    },
    "paperless": {
      "fields": {
        "BillerID": "",
        "CustomerPaperlessID": "",
        "InvoiceTypeID": "",
        "PaperlessFlag": "",
        "CustomerID": "",
        "AccountNumber": "",
        "EmailAddress": ""
      }
    },
    "scheduledPayments": {
      "fields": {
        "BillerID": "",
        "ScheduledPaymentID": "",
        "PaymentAmount": "",
        "CustomerID": "",
        "AccountNumber": "",
        "InvoiceID": "",
        "InvoiceNumber": ""
      }
    },
    "autopay": {
      "fields": {
        "BillerID": "",
        "CustomerAutoPayID": "",
        "InvoiceTypeID": "",
        "AutopayFlag": "",
        "CustomerID": "",
        "AccountNumber": "",
        "EmailAddress": ""
      }
    },
    "changelogs": {
      "fields": {
        "BillerID": "",
        "CustomerID": "",
        "AccountNumber": "",
        "Address": "",
        "City": "",
        "State": "",
        "EmailAddress": ""
      }
    },
    "scheduledPaymentUpdate": {
      "fields": {
        "BillerID": "",
        "ScheduledPaymentHistoryID": "",
        "Description": "",
        "ScheduledPaymentID": "",
        "AccountNumber": "",
        "InvoiceID": "",
        "InvoiceNumber": ""
      }
    },
    "autopayPaymentMethodChange": {
      "fields": {
        "BillerID": "",
        "CustomerAutoPayID": "",
        "DefaultBankID": "",
        "DefaultCreditCardID": "",
        "InvoiceTypeID": "",
        "AutopayFlag": "",
        "CustomerID": "",
        "AccountNumber": "",
        "EmailAddress": ""
      }
    },
    "achRejects": {
      "fields": {
        "BillerID": "",
        "AccountNumber": "",
        "invoiceNumber": "",
        "PaymentAmount": "",
        "PaymentDate": "",
        "PayAccount": "",
        "PayType": "E",
        "TransactionId": "",
        "ConfCode": ""
      }
    },
    "chargebacks": {
      "fields": {
        "BillerID": "",
        "AccountNumber": "",
        "invoiceNumber": "",
        "PaymentAmount": "",
        "PaymentDate": "",
        "PayAccount": "" ,
        "PayType": "C",m
        "TransactionId": "",
        "ConfCode": ""
      }
    },
    "payByText": {
      "fields": {
        "BillerID": "",
        "AccountNumber": "",
        "PaybyText": "",
        "PhoneNumber": ""
      }
    }
  }
}

Pros
Very simple, single source of truth.
Easy to store in config secrets or nosql db.
Cons
Cross-biller queries harder (needs JSON_VALUE).
No FK constraints.
Option B — Hybrid JSON-in-SQL (Chosen)
Tables
BillerConfigPart (per section JSON)
BillerId
SectionKey
JsonBlob
UpdatedAt
UpdatedBy
2002
behavior
{ "isAuthentication": true, "isRetry": true, "isTransformation": false, "apiType": "REST" }
2025-08-29
pgannavarapu
2002
retry
{ "limit": 4, "waitMs": 3000, "retryOn": [500,502,503,504] }
2025-08-29
pgannavarapu
2002
authentication
{ "tokenUrl":"<SecondaryRTDREndpoint>", "endpointType":"POST", "apiType":"REST", "fields": { "grant_type":"client_credentials", "client_id":"", "client_secret":"", "scope": "" } }
2025-08-29
pgannavarapu
2002
aliases
{ "AcctNum": "AccountNumber" }
2025-08-29
pgannavarapu
BillerPayloadConfig (per payload JSON)
BillerId
PayloadKey
FieldsJson
EndpointUrl
HttpMethod
UpdatedAt
UpdatedBy
2002
payment
{ "BillerID":"", "PaymentID":"", "PaymentAmount":"", "CustomerID":"", "AccountNumber":"", "InvoiceID":"", "InvoiceNumber":"" }
PaymentsEndpoint
POST
2025-08-29
pgannavarapu
2002
paperless
{ "BillerID":"", "CustomerPaperlessID":"", "InvoiceTypeID":"", "PaperlessFlag":"", "CustomerID":"", "AccountNumber":"", "EmailAddress":"" }
PaperlessEndpoint
POST
2025-08-29
pgannavarapu
2002
scheduledPayments
{ "BillerID":"", "ScheduledPaymentID":"", "PaymentAmount":"", "CustomerID":"", "AccountNumber":"", "InvoiceID":"", "InvoiceNumber":"" }
PaymentsEndpoint
POST
2025-08-29
pgannavarapu
2002
autopay
{ "BillerID":"", "CustomerAutoPayID":"", "InvoiceTypeID":"", "AutopayFlag":"", "CustomerID":"", "AccountNumber":"", "EmailAddress":"" }
AutopayEndpoint
POST
2025-08-29
pgannavarapu
2002
changelogs
{ "BillerID":"", "CustomerID":"", "AccountNumber":"", "Address":"", "City":"", "State":"", "EmailAddress":"" }
PaymentsEndpoint
POST
2025-08-29
pgannavarapu
2002
scheduledPaymentUpdate
{ "BillerID":"", "ScheduledPaymentHistoryID":"", "Description":"", "ScheduledPaymentID":"", "AccountNumber":"", "InvoiceID":"", "InvoiceNumber":"" }
PaymentsEndpoint
POST
2025-08-29
pgannavarapu
2002
autopayPaymentMethodChange
{ "BillerID":"", "CustomerAutoPayID":"", "DefaultBankID":"", "DefaultCreditCardID":"", "InvoiceTypeID":"", "AutopayFlag":"", "CustomerID":"", "AccountNumber":"", "EmailAddress":"" }
AutopayEndpoint
POST
2025-08-29
pgannavarapu
2002
achRejects
{ "BillerID":"", "AccountNumber":"", "invoiceNumber":"", "PaymentAmount":"", "PaymentDate":"", "PayAccount":"", "PayType":"E", "TransactionId":"", "ConfCode":"" }
ACHRejectsEndpoint
POST
2025-08-29
pgannavarapu
2002
chargebacks
{ "BillerID":"", "AccountNumber":"", "invoiceNumber":"", "PaymentAmount":"", "PaymentDate":"", "PayAccount":"", "PayType":"C", "TransactionId":"", "ConfCode":"" }
PaymentsEndpoint
POST
2025-08-29
pgannavarapu
2002
payByText
{ "BillerID":"", "AccountNumber":"", "PaybyText":"", "PhoneNumber":"" }
PayByTextEndpoint
POST
2025-08-29
pgannavarapu
Pros:
 good balance; partial updates; JSON remains human-readable; decent SQL queryability.
Cons:
 still need JSON validation; slightly more complex than a single file.
9. Redis Caching Strategy
Keys
:
cfg:{billerId}:behavior
cfg:{billerId}:retry
cfg:{billerId}:auth
cfg:{billerId}:payload:{payloadKey}
cfg:{billerId}:version

Values
: JSON blobs from Option C tables.
Version
: Cache-busting when config changes.
TTL
: Optional (e.g., 24h).
10. Generic Design Patterns
ConfigProvider (Facade)
 — fetches typed DTOs from Redis/SQL.
Builder (Builder)
 — builds payload from 
PayloadCfg
.
ValueResolver (Strategy)
 — resolve missing fields dynamically.
TransformationService (Chain/Strategy)
 — applies optional transformations.
 n(Adapter)
 — abstracts HTTP layer.
RetryPolicy (Policy)
 — Polly-driven retry logic.
11. Recommendation
Adopt Option B (Hybrid JSON-in-SQL + Redis)
 as the default approach.
Keep JSON editing (Option B) for onboarding, then publish to SQL.
Use Option A only where compliance requires strict relational rigor.
Provide an 
admin tool
 to publish JSON → SQL → Redis refresh.
 URL:/spaces/PE/pages/4613865541/Design+Configuration-Driven+DataPump+v2