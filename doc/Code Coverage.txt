Overview
This guide will walk through the definition and customization of the unit test runner‚Äôs code coverage reporting output. Specifically, this guide will discuss the coverage task that runs as part of the CI process, how to run the coverage task locally, customizing the test runner‚Äôs evaluation targets, collected metrics, and evaluation of improvement areas.
Prerequisites
Make sure the 
.NET CLI
 is installed and available for use.
Install the 
.NET ReportGenerator Tool
 to run and produce reports locally.
Install the 
Fine Code Coverage
 Visual Studio Plugin - 
Note - UNSURE IF THIS IS OBSOLETE - DOES NOT APPEAR TO WORK IN VS2022
In Visual Studio, 
Extensions ‚Üí Manage Extensions
, search for 
Fine Code Coverage
, install.
What is Code Coverage?
Code Coverage, put simply, is just the amount of code that is ‚Äútouched‚Äù or executed when a given codebases' unit tests are run. 
`dotnet`
 includes this functionality out of the box via its 
dotnet test
 command - specifically, .NET uses the 
Coverlet
 framework for this task. Coverlet is included by default in all .NET Unit Testing projects when they are scaffolded.
You will often see the package in the 
.csproj
 of a generated Unit Test project:
<PackageReference¬†Include="coverlet.collector"¬†Version="x.x.x"/>
Coverlet evaluates unit test coverage at 3 levels:
Line
Branch
Method
Running Code Coverage Locally
There are two primary methods of viewing Code Coverage reports locally - using the built-in Visual Studio Extension and using the 
dotnet reportgenerator
 tool. It‚Äôs highly recommended that you install and are familiar with both methods - the latter method is what will be run in the CI task as part of the build/release pipeline.
Report Generator
The Report Generator dotnet tool is the preferred method of evaluating Code Coverage reports. It is a simple 
dotnet
 package that can be installed via CLI. The easiest installation path for this tool is as follows:
Open a Command Line
Run 
dotnet tool install -g dotnet-reportgenerator-globaltool
 - this will install the 
reportgenerator
 in the default install directory.
Close command line session and open a new one, re-loading the environment.
Generate a coverage report using 
dotnet test
To use the tool, run 
reportgenerator [options]
Example
Once the 
reportgenerator
 tool is installed on your local machine, you can run a 
dotnet test
 session with coverage by supplying additional args to the 
dotnet test
 command
powershell
$\> dotnet test --collect:"XPlat Code Coverage" --results-directory ./TestResults
Whenever this command is run at the repository root (wherever the 
.sln
 resides) - a test run will commence, and you should see all of the regular output from a 
dotnet
 unit testing session. When the test run is finished - you should now have a 
TestResults
 folder that has been created in the repository‚Äôs root folder alongside other files.
note
Be aware that, by default, running the command 
without
 the 
--results-directory
 switch will create the 
TestResults
 folder within the Unit Test project folder. There may also be a top-level 
TestResults
 folder created in this case that has additional output files from the test run - though it will not contain the report file that will be used in later steps by the 
reportgenerator
 tool.


Be aware that, by default, running the command 
without
 the 
--results-directory
 switch will create the 
TestResults
 folder within the Unit Test project folder. There may also be a top-level 
TestResults
 folder created in this case that has additional output files from the test run - though it will not contain the report file that will be used in later steps by the 
reportgenerator
 tool.


Inside the 
TestResults
 folder, there will be individual folders, denoted by a 
Guid
 value, for each test run that is performed.
powershell
# Successful output from the `dotnet test` command - make note of the folder/file name.
Attachments:
  $> ~\TestResults\764908f9-feba-4c1c-b076-9fc6d75994d3\coverage.cobertura.xml

# Check the TestResults folder
$\> ls TestResults

Directory: $\TestResults

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----          6/2/2025   1:06 PM                00e4dbfa-8a85-4dba-9bd1-816a5b1b70af
d-----         6/16/2025  11:02 AM                764908f9-feba-4c1c-b076-9fc6d75994d3
With the test run completed, we should now have a single Cobertura report in the 
TestResults/{guid}
 folder:
powershell
$\> ls TestResults\764908f9-feba-4c1c-b076-9fc6d75994d3

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----         6/16/2025  11:02 AM         281423 coverage.cobertura.xml


$\> cat TestResults\764908f9-feba-4c1c-b076-9fc6d75994d3\coverage.cobertura.xml

<?xml version="1.0" encoding="utf-8"?>
<coverage line-rate="0.4343" branch-rate="0.39840000000000003" 
          version="1.9" timestamp="1750086141" 
          lines-covered="576" lines-valid="1326" 
          branches-covered="106" branches-valid="266">

# etc.
Once you have confirmed that there is a valid XML report in the indicated folder, you can now use the 
reportgenerator
 to make a friendlier version.
powershell
$\> reportgenerator `
-reports:"TestResults\764908f9-feba-4c1c-b076-9fc6d75994d3\coverage.cobertura.xml" `
-targetdir:"coveragereport" `
-reporttypes:Html
Once this command has been run, you should now have a new folder - 
coveragereport
 - which will contain static HTML output that you can open in your browser and view the test coverage results in a more visual manner. Within the folder, navigate to the 
index.html
 and open it in your browser of choice.
Rendered Coverage Report
Fine Code Coverage Visual Studio Extension
:construction:
1f6a7
üöß
#FFFAE6
Note that this extension does not currently appear to be compatible with Visual Studio 2022. It is, however, likely that it will be updated and have compatibility in the future. I have left this documentation section in place for awareness - but would encourage you to try installing this extension and see if you can get it working. If you can, please update this documentation and provide additional details.
The Fine Code Coverage VS Extension is an easy way to view test coverage while developing locally. It can be installed directly in Visual Studio by accessing the 
Extensions
 context menu and selecting 
Manage Extensions
Visual Studio 2022 - Manage Extensions Context Menu
Subsequently, it can be searched for and installed from the resultant Extension Manager window.
Fine Code Coverage in the Extension Manager
Once the extension has been installed, you will be required to close and re-open Visual Studio for the extension to install.
You may also choose to install the 
VSIX file, directly from the Visual Studio Marketplace
. In this case, simply run the file once it has been downloaded and it should install the extension into your Visual Studio instance.
Coverage Customization via RunSettings
You may have noticed that the 
example above
 output a report that indicated only 43% test coverage. If we go back and look at each individual item that was evaluated - we will likely see that there are certain files that are typically excluded from unit testing or that have very little value to test, overall.
As an example, 
Program.cs
 or 
Startup.cs
, where your program is bootstrapped typically is not evaluated for coverage (though extension methods that provided dependency registration shortcuts may need to be included) - app settings or configuration files represented by POCOs, infrastructure classes, or code that requires integration vs. unit testing may also be present.
We want to maintain an accurate gauge of not just what is tested, but what 
should be tested
. 
This is where the 
.runsettings
 file becomes an asset. While you can simply create the 
.runsettings
 file manually, I‚Äôd recommend installing the Visual Studio extension that provides the file template and modify from that point forward.
Adding RunSettings Templates to Visual Studio
Similar to the steps above for the fine code coverage tool - you can install the 
Runsettings
 Visual Studio extension by accessing the 
Extensions ‚Üí Manage Extensions
 options from the context menu at the top of the IDE. Search for 
runsettings
 and you should find the appropriate item in the Extension Manager:
Runsettings extension in VS Extension Manager
After installing the Runsettings extension, you should now be able to add a 
.runsettings
 file via template to your project. Right click the 
.sln
 in Visual Studio, and select 
Add ‚Üí New Item
Right-click context menu
There are 3 templates provided by the Runsettings extension. For our current example, we‚Äôll just use the 
CoverageNoParallel
 template - this should be the easiest one to modify with the least amount of headache - select this template and name the file 
Coverage.runsettings
 or 
CodeCoverage.runsettings
.
CoverageNoParallel Template
Once you have added the 
.runsettings
 file, Visual Studio should create a containing 
Solution Items
 folder at the repository root - you can maintain this folder or remove it and re-add the file to a top-level 
Solution Folder
 if desired - this is an optional step.
Result of generating 
Coverage.runsettings
 in Visual Studio
Configuring the RunSettings file for Code Coverage
The generated 
.runsettings
 file has a lot of noise that can be disregarded or removed. We really just want to configure this to provide settings for the 
XPlat Code Coverage
 collector such that it disregards items that are unnecessary for test coverage evaluation.
With the 
.runsettings
 file open, skip over the 
RunConfiguration
 section for now and find the 
DataCollectionRunSettings
 tag. Nested inside of this XML tag is a 
DataCollectors
 node containing multiple 
DataCollector
 tags. Remove anything within, preserving the opening and closing 
DataCollectors
 tags.
Once anything between the 
DataCollectors
 open and close tags has been removed, modify the XML to resemble the following:
xml
<DataCollector friendlyName="XPlat Code Coverage">
  <Configuration>
      <!-- We will add additional configuration here in subsequent steps -->
  </Configuration>
</DataCollector>
<InProcDataCollectionRunSettings>
  <InProcDataCollectors>
      <InProcDataCollector assemblyQualifiedName="Coverlet.Collector.DataCollection.CoverletInProcDataCollector, coverlet.collector, Version=1.1.0.0, Culture=neutral, PublicKeyToken=null"
						   friendlyName="XPlat Code Coverage"
						   enabled="True"
						   codebase="coverlet.collector.dll" />
  </InProcDataCollectors>
</InProcDataCollectionRunSettings>
This will configure the 
.runsettings
 to be used whenever we run 
dotnet test
 and specify the ‚ÄúXPlat Code Coverage‚Äù collector ‚Üí 
dotnet test --collect:"XPlat Code Coverage"
. Now, we can begin adding exclusions in the 
Configuration
 section.
xml
<Configuration>
  <!-- Add the reporting formats that will be used -->
  <Format>cobertura,opencover</Format>
  
  <!-- Exclude the test assembly from evaluation -->
  <IncludeTestAssembly>false</IncludeTestAssembly>
  
  <!-- Skip the auto properties from coverage evaluation. -->
  <SkipAutoProps>true</SkipAutoProps>

  <!-- Exclude any code with the following attributes -->
  <ExcludeByAttribute>Obsolete,GeneratedCodeAttribute,CompilerGeneratedAttribute</ExcludeByAttribute>

  <!-- Exclude Test projects -->
  <Exclude>[.*.Tests?]*</Exclude>
	
  <!-- Exclude Program/Startup, Worker services, POCOs, and Infrastructure classes - Program/Startup Extensions, Exceptions, and Settings files.-->
  <ExcludeByFile>[*]Exception.cs, **\Program.cs,**\HealthProbeWorkerService.cs, **\Consumers\*.cs, **\Infrastructure\Configuration\*.cs</ExcludeByFile>

</Configuration>
In the XML sample above, there are examples of several configuration elements that can be added and tweaked to customize the repository‚Äôs code coverage evaluation settings. You may need to tinker with this to some degree to ensure that everything is properly working whenever this settings file is used for test runs.
To use the 
.runsettings
 file - you can simply add another flag whenever you run 
dotnet test
 locally.
dotnet test --collect:"XPlat Code Coverage" --results-directory ./TestResults --settings Coverage.runsettings
With both 
cobertura
 and 
opencover
 specified above, you should also see two attachments have been generated instead of the one that was previously created.
bash
Attachments:
  .\TestResults\ad235e3d-1f7d-44fa-a37f-d88e2dd77efb\coverage.cobertura.xml
  .\TestResults\ad235e3d-1f7d-44fa-a37f-d88e2dd77efb\coverage.opencover.xml
Now run the 
reportgenerator
 with the new file.
bash
 reportgenerator -reports:".\TestResults\ad235e3d-1f7d-44fa-a37f-d88e2dd77efb\coverage.cobertura.xml" -targetdir:"coveragereport" -reporttypes:Html
2025-06-16T12:25:27: Arguments
2025-06-16T12:25:27:  -reports:.\TestResults\ad235e3d-1f7d-44fa-a37f-d88e2dd77efb\coverage.cobertura.xml
2025-06-16T12:25:27:  -targetdir:coveragereport
2025-06-16T12:25:27:  -reporttypes:Html
2025-06-16T12:25:27: Writing report file 'coveragereport\index.html'
2025-06-16T12:25:27: Report generation took 0.5 seconds
The report will overwrite the existing one in the 
codecoverage
 directory, and you should now be able to open the updated report.
Updated Code Coverage Metrics with .runsettings configuration
Run Settings for CI/CD
As of 06/16/2025
 - The 
.runsettings
 file can be passed to the build/deploy templates in the 
Platform
 project template repositories 
azure-pipelines-container-templates
 and 
azure-pipelines-nuget-templates
 - for containerized applications and NuGet packages, respectively.
See here for example
To utilize your repository‚Äôs 
.runsettings
 file - you can include the path to the file in the pipeline template for your build/deploy task:
yaml
trigger: none

resources:
  repositories:
    - repository: templates
      type: git
      name: Platform/azure-pipelines-container-templates
      ref: refs/tags/platform-0/2.9.0

extends:
  template: stages/dotnet-container-build.yaml@templates
  parameters:
    projectName: BillerReportGeneratorJob
    dockerFile: ./Dockerfile
    runSettingsFile: ./Coverage.runsettings # Include the .runsettings file as a param.
    nugetConfigPath: './nuget.config'
    imageName: biller-report-generator-job
    registry: acrglbimages1npd.azurecr.io
    gitversionYml: .devops/gitversion.yml
    extraBuildArgs: --build-arg NUGET_USERNAME=$(nuget_username) --build-arg NUGET_PAT=$(nuget_pat) --build-arg SEMVER="$(GitVersion.SemVer)" --build-arg NUGET_VERSION="$(GitVersion.NuGetVersion)"

variables:
  - group: Nuget Feed Reader
  - group: biller-application-dev

This will produce the same output during the pipeline run that we viewed when running the commands locally, above.
Code Coverage Results in Azure Pipelines run
Complete Example File
Expand to view complete .runsettings example from 'BillerReportGeneratorJob' 
xml
<?xml version="1.0" encoding="utf-8"?>
<!-- File name extension must be .runsettings -->
<!-- For more information, see https://docs.microsoft.com/en-us/visualstudio/test/configure-unit-tests-by-using-a-dot-runsettings-file?view=vs-2022  -->

<RunSettings>
    <RunConfiguration>
        <!-- See https://github.com/microsoft/vstest-docs/blob/master/docs/configure.md -->
        <!-- 1. Test related settings -->
        <!-- [x86] | x64: architecture of test host -->
        <!--<TargetPlatform>x86</TargetPlatform>-->
        <!-- Framework35 | [Framework40] | Framework45 -->
        <!--<TargetFrameworkVersion>Framework40</TargetFrameworkVersion>-->
        <!-- Path to Test Adapters -->
        <!--<TestAdaptersPaths>%SystemDrive%\Temp\foo;%SystemDrive%\Temp\bar</TestAdaptersPaths>-->
        <TreatTestAdapterErrorsAsWarnings>false</TreatTestAdapterErrorsAsWarnings>
        <!-- Path relative to solution directory -->
        <ResultsDirectory>.\TestResults</ResultsDirectory>
        <!-- 0 = As many processes as possible, limited by number of cores on machine, 1 = Sequential (1 process), 2-> Given number of processes up to limit by number of cores on machine-->
        <MaxCpuCount>1</MaxCpuCount>
        <!-- TestSessionTimeout was introduced in Visual Studio 2017 version 15.5 -->
        <!-- Specify timeout in milliseconds. A valid value should be >= 0. If 0, timeout will be infinity-->
        <TestSessionTimeout>10000</TestSessionTimeout>
        <!-- Specify a Boolean value, which defines the exit code when no tests are discovered.-->
        <TreatNoTestsAsError>false</TreatNoTestsAsError>
        <!-- STA | MTA  default is STA for .NET Full and MTA for .NET Core-->
        <!--<ExecutionThreadApartmentState>STA</ExecutionThreadApartmentState>-->
        <!-- Disables in-assembly parallel execution, applies to both MSTest and NUnit -->
        <DisableParallelization>false</DisableParallelization>
        <DisableAppDomain>false</DisableAppDomain>
        <CollectSourceInformation>true</CollectSourceInformation>
        <!-- Runner related configuration -->
        <BatchSize>10</BatchSize>
    </RunConfiguration>
    <DataCollectionRunSettings>
		<DataCollectors>
			<DataCollector friendlyName="XPlat Code Coverage">
				<Configuration>
					    <Format>cobertura,opencover</Format>
						<IncludeTestAssembly>false</IncludeTestAssembly>
					    <SkipAutoProps>true</SkipAutoProps>
					    <ExcludeByAttribute>Obsolete,GeneratedCodeAttribute,CompilerGeneratedAttribute</ExcludeByAttribute>

					    <!-- Exclude Tests & Producer Example projects -->
						<Exclude>[.*.Tests?]*,[*]Biller.ReportGenerator.ProducerExample*</Exclude>
	
					    <!-- Exclude Program/Startup, Worker services, POCOs, and Infrastructure classes - Program/Startup Extensions, Exceptions, and Settings files.-->
					    <ExcludeByFile>[*]Exception.cs, **\Program.cs,**\HealthProbeWorkerService.cs, **\Consumers\*.cs, **\Infrastructure\Configuration\*.cs</ExcludeByFile>

				</Configuration>
			</DataCollector>
		</DataCollectors>
    </DataCollectionRunSettings>
	<InProcDataCollectionRunSettings>
		<InProcDataCollectors>
			<InProcDataCollector assemblyQualifiedName="Coverlet.Collector.DataCollection.CoverletInProcDataCollector, coverlet.collector, Version=1.1.0.0, Culture=neutral, PublicKeyToken=null"
						   friendlyName="XPlat Code Coverage"
						   enabled="True"
						   codebase="coverlet.collector.dll" />
		</InProcDataCollectors>
	</InProcDataCollectionRunSettings>


    <!-- NUnit3 adapter, uncomment sections to set as appropriate, numeric, booleans, enums have their default values below, except RandomSeed -->
    <!-- For documentation, see https://docs.nunit.org/articles/vs-test-adapter/Tips-And-Tricks.html -->
    <NUnit>
        <!--<BasePath>D:\Dev\NUnit\nunit3-vs-adapter\demo\NUnitTestDemo\bin\Release</BasePath>-->
        <!--<PrivateBinPath>extras;more.extras</PrivateBinPath>-->
        <DefaultTimeout>0</DefaultTimeout>
        <!--<WorkDirectory>work</WorkDirectory>-->
        <InternalTraceLevel>Off</InternalTraceLevel>
        <!--<RandomSeed>1234567</RandomSeed>-->
        <NumberOfTestWorkers>-1</NumberOfTestWorkers>
        <Verbosity>0</Verbosity>
        <!--<UseVsKeepEngineRunning>false</UseVsKeepEngineRunning>-->
        <!--<ShadowCopyFiles>false</ShadowCopyFiles>-->
        <!--<DefaultTestNamePattern>{m}{a}</DefaultTestNamePattern>-->
        <!--<DomainUsage>Single</DomainUsage>-->
        <DumpXmlTestDiscovery>false</DumpXmlTestDiscovery>
        <DumpXmlTestResults>false</DumpXmlTestResults>
        <ShowInternalProperties>false</ShowInternalProperties>
        <!--<TestOutputXml>TestOutputXml</TestOutputXml>-->
        <!--<Where></Where>-->
        <!-- NUnit filter expression, see https://docs.nunit.org/articles/nunit/running-tests/Test-Selection-Language.html  -->
        <ConsoleOut>1</ConsoleOut>
        <UseTestNameInConsoleOutput>true</UseTestNameInConsoleOutput>
        <StopOnError>false</StopOnError>
        <SkipNonTestAssemblies>false</SkipNonTestAssemblies>
        <MapWarningTo>Skipped</MapWarningTo>
        <!--Passed, Failed or Skipped-->
        <DisplayName>Name</DisplayName>
        <!--Name, FullName or FullNameSep-->
        <FullnameSeparator>:</FullnameSeparator>
        <DiscoveryMethod>Current</DiscoveryMethod>
        <!--Legacy or Current-->
        <AssemblySelectLimit>2000</AssemblySelectLimit>
        <NewOutputXmlFileForEachRun>false</NewOutputXmlFileForEachRun>
        <IncludeStackTraceForSuites>true</IncludeStackTraceForSuites>
        <ExplicitMode>Strict</ExplicitMode>
        <SkipExecutionWhenNoTests>false</SkipExecutionWhenNoTests>
    </NUnit>
</RunSettings>

Important: Review 
.runsettings
 Changes Carefully
When reviewing pull requests, pay close attention to any modifications in
 
.runsettings
 
files, especially in sections that configure code coverage exclusions.
Why This Matters
Changes to the following settings can artificially inflate code coverage metrics or hide untested code:
Exclude
 entries under 
<CodeCoverage>
Assembly filters (e.g., 
[*]MyAssembly.*
)
File or class-level exclusions
Attribute-based exclusions (e.g., 
[ExcludeFromCodeCoverage]
)
What to Look For
New exclusions
 added without justification
Broad filters
 that may unintentionally exclude critical code
Commented-out exclusions
 that could be re-enabled later
Missing context
 or explanation in the PR description
Best Practices
Require a clear explanation for any exclusion changes
Cross-check exclusions against the codebase to ensure they are necessary
Consider adding a test or comment to justify exclusions
Final Thought
While tuning Code Coverage with a 
.runsettings
 file is a great way to more accurately represent the health of your codebase and highlight how well tested your program is - it should not be abused. It is important to surface realistic metrics on the health of a codebase so that it may be properly evaluated and improved over time, if need be - these metrics can provide valuable insights into how well a codebase has been maintained, how difficult it is to work with, and how well known/tested it is.
Metrics
If you have previously run a code coverage report, either locally or via pipeline, and have scrutinized the output to a greater degree - you will notice that there are two sections to the report, highlighting slightly different things. These two sections are
Risk Hotspots
Coverage
The 
Coverage
 section covers the percentage of line and branch coverage (also method, if enabled) while also providing metrics on the number of lines available for coverage, what‚Äôs covered, and what‚Äôs uncovered.
The former section, 
Risk Hotspots
, is the portion that will be focused on for the following two headings - specifically the additional metrics that are surfaced, 
Cyclomatic Complexity
 and 
CRAP Score.
Coverage Report Risk Hotspot Section
Cyclomatic Complexity
Cyclomatic complexity
 is a calculated metric that describes how 
complex
 a particular program is. In our test coverage task, and many other code analysis tools, we evaluate this at the method level. More specifically, cyclomatic complexity describes how many linear control flow paths there are during a program‚Äôs execution - to put it simply, the more branching logic you have contained in a method, the higher the cyclomatic complexity of the method is.
This metric provides valuable insight into how maintainable your codebase is - it stands to reason that the more branches of logic you have in a particular program, the more possible choices there are during runtime execution, and thus there are more testable scenarios possible.
You can of course, disregard all of that, and just remember that a 
Cyclomatic Complexity score at or below 20 is desired and at or below 10 is ideal
 - though this is not always a hard and fast rule. Lower cyclomatic complexity tends to indicate that the code being evaluated is more modular, has less complex execution paths, and is (in theory) easier to test. Higher cyclomatic complexity scores tend to indicate that a method is a good candidate for refactoring.
Change Risk Anti-Patterns (CRAP)
The 
Change Risk Anti-Pattern, or CRAP, 
score is a metric based on a ratio between Cyclomatic Complexity and Unit Test Coverage. This metric seeks to highlight areas that are more complex but have less test coverage - increasing test coverage or decreasing Cyclomatic Complexity will both reduce the CRAP score - indicating that adding test coverage or decreasing complexity both decrease overall risk.
Resources
dotnet test command - .NET CLI | Microsoft Learn
Use code coverage for unit testing - .NET | Microsoft Learn
Configure unit tests with a .runsettings file
Code metrics - Cyclomatic complexity
Generate code metrics from the IDE or command line - Visual Studio (Windows) | Microsoft Learn
 URL:/spaces/PMK/pages/4415422478/Code+Coverage