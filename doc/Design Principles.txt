1. Single Responsibility Principle
Each container should do 
one thing well
. For example, a web server, a database, and a background worker should each run in separate containers.
2. Statelessness
Design your application to be 
stateless
. This means any state (like user sessions or temporary data) should be stored in external services like databases, caches (e.g., Redis), or object storage (e.g., S3).
3. Configuration via Environment Variables
Use 
environment variables
 for configuration (e.g., database URLs, API keys). This makes it easier to manage different environments (dev, staging, production) and aligns with the Twelve-Factor App methodology.
4. Minimal Base Image
Use 
lightweight base images
 (like Alpine Linux) to reduce the attack surface and improve build and deployment speed.
5. Health Checks
Implement 
readiness
 and 
liveness probes
 so orchestrators like Kubernetes can manage your app's lifecycle effectively.
6. Logging to STDOUT/STDERR
Write logs to 
standard output
 and 
standard error
. This allows container platforms to collect and manage logs centrally.
7. Graceful Shutdown
Handle 
SIGTERM
 and other termination signals gracefully to allow the app to clean up resources or finish processing before exiting.
8. Immutable Infrastructure
Treat containers as 
immutable
. If you need to make a change, build a new image and redeploy rather than modifying a running container.
9. Dependency Isolation
Bundle all dependencies within the container image to ensure consistency across environments.
10. Security Best Practices
Run containers as 
non-root users
.
Regularly 
scan images
 for vulnerabilities.
Use 
multi-stage builds
 to keep final images clean and secure.
 URL:/spaces/PMK/pages/4152655889/Design+Principles