Exception handling is made easy in .NET through the inclusion of the 
try, catch, finally
 keywords. These can be used to scope areas of code that have the potential to throw exceptions or where more granular resource management is needed.
Fundamental Example
c#
public void MyMethod(Guid id) {
  MyResult result;
  try 
  {  
     result = this._service.GetSomeDataSynchronouslyById(id); 
  }
  catch // NOTE: Bad example - most of the time, try to avoid generic `catch` blocks like this
  {
    // Something went wrong. Handle the error
  }
  finally // NOTE - The `finally` block always executes whether the `try` is successful or not.
  {
    // Clean up or handle any finalization scenario.
    // e.g. Close a database connection, delete a temporary file, etc.    
  }
  
  return result;
}
Best Practices
1. Always Use 
Meaningful 
catch
 Blocks and 
Explicit 
Exception Types. 
Avoid using empty 
catch
 blocks or only 
catch
 blocks dealing with the vanilla 
Exception
 type. Where possible, handle known exceptions
c#
// Logger = https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggerextensions?view=net-9.0-pp

public void MyMethod(Guid? id) {
  MyResult result;
  try
  {
    // 'id' was `null` when passed to this method.
    result = this._service.GetSomeDataSynchronously(id);
  }
  catch(ArgumentNullException argNullEx)
  {
    // Whoops, `id` was null - handle that situation here.
    this._logger.LogError(0, argNullEx, $"{nameof(MyMethod)} received null for parameter 'id'")
  }
  catch(ConnectionClosedException connectionClosedEx)
  {
    // Our service throws a `ConnectionClosedException` and maybe we'd rather retry the connection here, instead.
  }
  catch(Exception unhandled)
  {
     // The exception we received isn't explicitly handled - but this is a critical piece of code - so we need to be aware of it and perform any extra logging/telemetry sampling & cleanup, regardless.
  }
  finally
  {
     // Do some cleanup
     this._service.CloseConnection();
     this._logger.LogInformation("Method {0} finished execution at {1}", new [] { nameof(MyMethod), DateTime.UtcNow });
     // Output: Method MyMethod finished execution at 02/26/2025 17:25:24
  }
}
2. Utilize Built-in Pattern Matching for Multi-Conditional Exception Handling
Pattern matching is a powerful feature 
introduced in C# 8.0
 - it can be used in many different contexts but is particularly useful when dealing with granular exception handling conditions.
c#
  catch(ConnectionClosedException ex) when (ex.ErrorCode == 429)
  {
    // 429 indicates we're getting throttled.
    // We could implement exponential backoff at this point & begin rate-limiting our requests.
    this._logger.LogDebug(0, ex, $"{nameof(MyService)} threw an exception with HttpStatusCode 429. Backing off requests");
  }
  catch(ConnectionClosedException ex) when (ex.ErrorCode == 400)
  {
     // 400 Indicates a bad request - we probably need to determine why this happened.
     this._logger.LogError(0, ex)
  }
  catch(ConnectionCloseException ex)
  {
    // We have an expected exception type - but outside of the conditions we've chosen to handle.
    // Log this for debug/troubleshooting or alerting purposes.
  }
Another interesting example for handling multiple types of the same base exception:
c#
catch(IOException ex) when (ex is DirectoryNotFoundException){}
catch(IOException ex) when (ex is FileNotFoundException{}
catch(IOException ex) when (ex is FileLoadException){}
// etc.
3. Don’t Rethrow Exceptions
In general - exceptions should be handled, when possible, and not rethrown or overwritten. There 
are
 some potentially valid cases for throwing exceptions back to be handled by the caller - but these scenarios can typically be avoided through more defensive programming & implementation of resiliency patterns.
There are several nuances when rethrowing exceptions which are easier to illustrate through example:
throw
The below code block will catch an 
IOException
 thrown in the 
try
 block and subsequently throw that exception back to the caller, preserving all of the details that produced the exception.
This may end up being a nested 
InnerException
 to another exception type farther up the call stack - but the information on the original exception is preserved.
c#
catch(IOException ioEx)
{
   throw;
}
throw ex
 - 
Avoid Entirely
While the below code looks relatively innocuous - it is actually causing a lot of harm. Utilizing 
throw ex
 inside of a 
catch
 block destroys the original stack trace information from the underlying exception. Meaning that whatever error produced the original issue is completely lost as a result.
This creates issues that have the potential to be extremely difficult to troubleshoot and fix as most of the information regarding the originating exception are lost.
c#
catch(IOException ioEx)
{
  throw ioEx;
}
throw new Exception(ex.Message)
 - 
Avoid Most of the Time
Very much like the above block of code, throwing a new exception type will overwrite the original stack trace - the example highlighted 
new Exception(ex.Message)
 will lose all of the original stack trace information, including the specific type of exception produced & any information encapsulated by it.
c#
catch(IOException ioEx)
{
  // Now we have 0 idea that we even had an IOException
  // All stack trace info is gone - and even important data points from the exception itself are gone.
  throw new Exception(ioEx.Message);
}
While the above example should be avoided at all costs - there is one particular scenario in which this pattern can be useful. Below, we are throwing a new exception of a custom type - but preserving the original exception details by passing them as arguments to 
MyCustomException
.
This may be desired if there is a need for a custom exception type that drives system behavior - like autoscaling, alerting, etc.
c#
catch(IOException ioEx)
{
  throw new MyCustomException(ioEx, ioEx.Message);
}
4. Externalize Exception Messages for Better Maintenance
Keeping exception messages externalized in a static config class provides the benefit of allowing centralized maintenance of error messages while avoiding the inclusion of magic strings in the codebase. Even externalized, these types of messages can still be provided with custom parameters, allowing them to be meaningful in a wide variety of contexts.
c#
public static class InputOutputExceptionMessages {
   public static string MessageWithoutParameters => "Something went wrong";
   public static string DatabaseConnectionClosedMessage(string methodName, DateTime dateTime) => $"Database connection was closed while executing {methodName} at {dateTime}";
   public static string DatabaseConnectionThrottledMessage(string methodName, DateTime dateTime) => $"{methodName} - Received 429 response from database server at {dateTime}";
   public static string FileClosedMessage(string methodName, string fileName, DateTime dateTime) => $"{methodName} - File {fileName} was forcibly closed by the host process at {dateTime}";
}

// e.g. In Use
catch(Exception ex) when (ex is SocketException)
{
   this._logger.LogDebug(1, ex, InputOutputExceptionMessages.DatabaseConnectionClosedMessage(nameof(MyMethod), DateTime.UtcNow));
}
This can also be approached using C#'s 
ResourceManager
 if there are more robust localization requirements - 
see here for details
 on this type of approach
5. Avoid Using Exception Handling for Control Flow
This is a well-known, polyglot anti-pattern
 - exceptions are expensive when thrown - both in terms of the process the runtime undertakes to deal with them and the in-memory construction of 
Exception
 objects, themselves. In general, it is better 
to practice defensive programming
 and avoid throwing exceptions entirely, where possible. 
As just one of the many potential strategies for better error-handling - the 
Null Object pattern
 is a good defensive technique to avoid raising exceptions when an object is not defined at runtime.
c#
// Define a common interface for objects to share.
public interface ICustomer {
   public Guid Id { get; }
}

// One default implementation of `ICustomer`
public class Customer: ICustomer {
  public Guid Id { get; init; }
  public Customer(Guid? id) {
    ArgumentNullException.ThrowIfNull(id, nameof(id));
    Id = id.Value;
  }
  // Other stuff.   
}

// Create a Null Object that can be used in place of a valid `ICustomer`
public record NullCustomer: ICustomer {
   public Guid Id => Guid.Empty;
   public NullCustomer() {}
}

// Example - Customer Service making use of null object.
public class CustomerService: ICustomerService {
   
   public ICustomer GetCustomerById(Guid id) {
      var result = this._customerContext.Find(id);
    
      if(result == null) return new NullCustomer();
      
      return result;
   }
}

// Example - consumer handling null object.
public class WebApiController
{
   private readonly ICustomerService _service;
   public WebApiController(ICustomerService service) {
     this._service = service;
   }
   
   [HttpGet]
   public IActionResult GetCustomerById(Guid? id) {
       // We could definitely handle input validation here.
       Guid.TryParse(id, out var parsedId);
       
       // For the sake of example:
       var customer = this._service.GetCustomerById(parsedId);
       
       return customer is NullCustomer ? NotFound() : Ok(customer);
   }
}
Thus, we’ve handled a null case without even using 
try, catch, finally
Another great way to avoid exception handling for control flow is to use the built-in 
Try
 methods that exist on many .NET types
c#
Guid.TryParse(value, out var parsedId);
_dictionary.TryGetValue(key, out var value);
_queue.TryDequeue(out var elm);
// etc.
6. Use Built-In Exceptions Where Possible
The .NET Framework contains a ton of specific exception types that can be used for most common error-handling cases. When possible - these should be favored over more abstract exception types (i.e. 
Exception
, 
IOException
).
c#
// Do this
catch(ArgumentNullException ex)

// Not this
catch(Exception ex)

// Do this
catch(DirectoryNotFoundException ex)

// Not this
catch(IOException ex)

// Unless you're doing this
catch(IOException ex) when (ex is DirectoryNotFoundException){}
catch(IOException ex) when (ex is FileNotFoundException{}
catch(IOException ex) when (ex is FileLoadException){}
// etc.
There may be a need for 
Custom Exceptions
 in more specific cases.
Resources
Handling and throwing exceptions in .NET - .NET | Microsoft Learn
Design Guidelines for Exceptions - Framework Design Guidelines | Microsoft Learn
Best practices for exceptions - .NET | Microsoft Learn
Exception-handling statements - throw and try, catch, finally - C# reference | Microsoft Learn
Exceptions and Performance
Follow up - 
The True Cost of .NET Exceptions -- Solution | Microsoft Learn
 URL:/spaces/EA/pages/3376087268/Exception+Handling