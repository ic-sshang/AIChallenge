Overview
The 
Singleton Pattern 
is a 
creational 
design pattern that controls the lifetime of an object such that only a single instance of it can be created during runtime. It is one of the simplest patterns to implement and is arguably one of the most common patterns to show up regularly in the wild - it is also one of the most controversial patterns.
Singletons usually encapsulate the instantiation behavior of an object and delegate the creation & instance access through a 
static
 interface of some kind - whether that be a simple property on an existing class, a global variable, or a dedicated accessor/provider class.
It should be noted that 
singleton
 often holds two meanings, especially in modern software design, with it either referring to the design pattern, directly, or the concept of having a single instance of something - do note and understand that there is a difference between having one instance of something & implementing the singleton pattern.
Why It Is Useful
The singleton pattern can be useful when there is a need to have a single instance of an object persist throughout the lifetime of a program and be accessible to any caller, globally - either through a static reference or via a provided interface.
Some examples of 
good
 singletons include
Logging
Database, Cache, or Network Managment - 
Sometimes
Many .NET Database & Networking SDKs leverage Singletons to more effectively manage connection lifetimes, especially when there are expected to be many concurrent processes operating at once.
e.g.
 The 
HttpClient
 implemented in .NET Core, onward, is a singleton (or at least 
the web proxy component is
). Redis Cache is a single-threaded in-memory database that uses a singleton 
ConnectionMultiplexer
 
class that combines many concurrent processes into a single connection
.
When To Use It
There are few reasons to implement the singleton pattern directly these days. While the singleton 
concept 
is still very prevalent in software, it is more often done using Inversion of Control (IOC) and Dependency Injection (DI).
Revisiting the 
Why It Is Useful 
section above - a great example for an appropriate singleton use-case would be a 
Logger
 class.
Why?
Logging
 is used everywhere throughout a program and the logger isn’t an object that needs to be removed from memory.
All of the data flow to a 
Logger
 is downward - it only accepts input from its consumers and doesn’t expose anything upward - i.e. only logs are pushed to the logger, nothing is returned or pushed back up.
There’s little ambiguity with the responsibility of Logging - i.e. there should be no other dependencies a Logger maintains internally beyond writing logs and possibly sinking them to a file or an observability platform.
When Not to Use It - Why Singletons Are Bad
While 
Singleton Instances
 are still very common, the Singleton pattern directly is often considered
 a code smell 
and bad practice.
Why?
Singletons are typically used as “Global instances” which are placed as direct dependencies of a class.
This hides an application’s dependencies, rather than exposing them via an interface. Making the consumer nearly impossible to test as a result.
This creates a circumstance where multiple, unrelated processes can manipulate or mutate the state of the singleton.
The alternative and correct mechanism of handling this scenario is to 
use Dependency Injection, instead
.
Coupling - 
Singletons make refactoring and testing code extremely difficult, if not impossible.
They maintain state over the lifetime of the application - meaning any reproduction of behavior requires a sequential application of specific activities.
Consider- If you’re trying to test, you now need to ensure the object is instantiated first & configured with any necessary settings, manually - you cannot just mock or fake these, they now have to follow a procedure - this means that you now have an order of operations you need to account for rather than just being able to test certain behavior directly.
Also note - this is specific to 
application
 behavior. Back to the Logging example - if the application suddenly stops logging, it’s not really affecting the application - just your visibility of what’s happening in it. 
Example
Classic Usage - Not Thread Safe - 
??=
c#
public class MySingleton {
  private static MySingleton instance;
  public static MySingleton Instance => instance ??= new MySingleton();
  
  private MySingleton(){}
}
Classic Usage - Synchronous
 + 
Thread Safe
The singleton can be made thread-safe through use of a 
lock
 - note the 
lock
 operation is expensive, however, and we’ve now incurred a performance penalty for access.
c#
public class MySingleton {
  // Add a lock object to control access.
  private static readonly object instanceLock = new();
  
  private static MySingleton instance;
  public static MySingleton Instance 
  {
      get 
      {
         lock(instanceLock) 
         {
            return instance ??= new MySingleton();
         }
      }
  }
  
  private MySingleton(){}
}
Classic Usage - Synchronous
 + 
Thread Safe + Lazy Initialization
Better than the above, the 
lock
 is gone & 
Lazy<T>
 is used for initialization, instead. This guarantees the object is only created the first time that it is accessed. 
Lazy
 also provides some 
additional options for controlling the thread-safety on a case-by-case basis
.
c#
public class MySingleton {

  private static Lazy<MySingleton> lazyInstance = new Lazy<MySingleton>(() => new MySingleton());
  public static MySingleton Instance => lazyInstance.Value;
  
  private MySingleton(){}
}
Resources
Singleton
Implementing the Singleton Pattern in C#
Singleton Vs Static Classes in C#
Singleton I love you, but you're bringing me down (re-uploaded)
Google Testing Blog: Root Cause of Singletons
Patterns I Hate #1: Singleton : Pure Danger Tech
 URL:/spaces/EA/pages/4141809667/Singleton+Pattern