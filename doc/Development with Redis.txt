Redis Session State Management Development
What is the benefit of using Redis for session state management?
The simplest answer is to move away from being tied to one server.
What we are using before Redis was simply InProc, which means that we were using server memory to store our sessions.
As a result, we need to enable a "sticky port" to maintain a user on one particular server to use their current session. 
With Redis, the session objects live in an entirely different area. This means that a user can make a request to Web1 to create the session and then land on Web9 on the next page request without losing their sessions.
This opens up the door to finally removing the "sticky port" on our servers, which means we'll get rid of some of our known problems.
An example of a problem is:
    - IVR Tech's requests will be tied to one of the web servers instead of being load-balanced on all machines.
The addition of the Redis session state management is a huge plus when we start thinking about containerizing our applications.
In that scenario, we can think of our servers as cattle and remove any container, and the user would not experience a service disruption.
What is Azure Cache?
Azure Cache for Redis provides an in-memory data store based on the Redis software. Redis improves the performance and scalability of an application that uses backend data stores heavily. It's able to process large volumes of application requests by keeping frequently accessed data in the server memory, which can be written to and read from quickly. Redis brings a critical low-latency and high-throughput data storage solution to modern applications.
Excerpt taken from here: 
https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-overview
 
What is Redis?
Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache, and message broker. Redis provides data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs, geospatial indexes, and streams. Redis has built-in replication, Lua scripting, LRU eviction, transactions, and different levels of on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster.
Excerpt taken from here: 
https://redis.io/documentation
What are we using for Session State Management?
We are using a NuGet package called Microsoft.Web.RedisSessionStateProvider to implement the 
http://ASP.NET
  SessionStateModule that is used for managing Session events.
Link to the NuGet package repository:
https://github.com/Azure/aspnet-redis-providers/tree/NuGet-Release/RedisSessionStateProvider-2.2.6/src
 
Configuration
Follow this Microsoft documentation to apply Redis session state management to an application.
https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-aspnet-session-state-provider
 
This has already been configured for MyIIS, ICCRM, and ICDocumentation. 
Developing with Redis Session State Management
We can think of Redis as a dictionary that supports both strings and binary content.
When sending data over to the Redis server, we need to serialize our session objects into JSON.
To ensure items will be properly serialized into JSON, we need to add the "Serializable" attribute to our custom classes. 
Examples:
Visual Basic .NET
<Serializable()>
Public Class CustomClass
	Public Property Name as String
End Class
C#
[Serializable()]
public class CustomClass
{ 
    public string Name { get; set; }
}
Security
Be mindful of what is being stored in session. The data stored in session can likely be pushed up to Redis as clear text.
So, when dealing with Sensitive information like Credit Cards or Bank Account information, we need to encrypt those values when the object is serializing and decrypt them when deserializing. 
We'll be using three attributes to define methods needed in the serialization process. 
OnSerializing
  This is used when we are starting the serialization process. We need to encrypt the values to ensure what is in the JSON representation of the object does not contain sensitive clear text values. 
OnSerialized
  This is used after the object has been serialized. There may be cases where we need to serialize the object, but still use the object after it has been serialized. This will reset the value to it's clear text form. 
OnDeserialized
  This is used when we have deserialized the object. We need to decrypt the value to allow the application to read the clear text value. 
Examples:
Visual Basic .NET
<Serializable>
Public Class AchInformation
	Public CustomerBankID As Integer
	Public BankAccountNumber As String = String.Empty
	Public BankRTE As String = String.Empty
	Public CheckNumber As String = String.Empty
	Public BankAccountType As BankAccountTypes 

	<Runtime.Serialization.OnSerializing>
	Protected Sub OnSerializingMethod(context As Runtime.Serialization.StreamingContext)
		BankAccountNumber = clsCrypto.Encrypt(BankAccountNumber, CloudPaymentSession.SecretKey)
	End Sub
	<Runtime.Serialization.OnSerialized>
	Protected Sub OnSerializedMethod(context As Runtime.Serialization.StreamingContext)
		BankAccountNumber = clsCrypto.Decrypt(BankAccountNumber, CloudPaymentSession.SecretKey)
	End Sub

	<Runtime.Serialization.OnDeserialized>
	Protected Sub OnDeserializedMethod(context As Runtime.Serialization.StreamingContext)
		BankAccountNumber = clsCrypto.Decrypt(BankAccountNumber, CloudPaymentSession.SecretKey)
	End Sub
End Class
C#
[Serializable]
public class AchInformation
{
    public int CustomerBankID;
    public string BankAccountNumber = string.Empty;
    public string BankRTE = string.Empty;
    public string CheckNumber = string.Empty;
    public BankAccountTypes BankAccountType;

    [System.Runtime.Serialization.OnSerializing]
    protected void OnSerializingMethod(System.Runtime.Serialization.StreamingContext context)
    {
        BankAccountNumber = clsCrypto.Encrypt(BankAccountNumber, CloudPaymentSession.SecretKey);
    }
    [System.Runtime.Serialization.OnSerialized]
    protected void OnSerializedMethod(System.Runtime.Serialization.StreamingContext context)
    {
        BankAccountNumber = clsCrypto.Decrypt(BankAccountNumber, CloudPaymentSession.SecretKey);
    }

    [System.Runtime.Serialization.OnDeserialized]
    protected void OnDeserializedMethod(System.Runtime.Serialization.StreamingContext context)
    {
        BankAccountNumber = clsCrypto.Decrypt(BankAccountNumber, CloudPaymentSession.SecretKey);
    }
}
Recommendations
DO NOT
 store large datasets in session. We want to avoid this because each page request will post an update back to the Redis server and get the data again. This will introduce slowness on the application as we wait for the data to come back. 
FAQ:
What happens when I have a property using an object from a library I cannot control?
Well, depends on the following things:
Does it absolutely need to be in Session?
Yes
Why do you need it in session? Look for an alternative since we cannot control that external DLL. 
No
Does it need to be in the class?
Yes	
  The following code will make it so the object is not serialized, and when it's deserialized it will obtain the default value.
  Code Sample: 
  Visual Basic .NET
<Serializable()>
Public Class CustomClass
	<NonSerializable()>
	Public Property Name as String
End Class
  C#
[Serializable()]
public class CustomClass
{
    [NonSerializable()]
    public string Name { get; set; }
}
  If these code changes do not work for you, it may mean we have to change the approach on why we need to store it in session. Bring these cases up to the Tech Lead (TL).
Related
More Info
http://ASP.NET
 
https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-aspnet-session-state-provider
 
https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-overview
 
https://github.com/Azure/aspnet-redis-providers/tree/NuGet-Release/RedisSessionStateProvider-2.2.6/src
 
https://redis.io/documentation
 URL:/spaces/ED/pages/2806546515/Development+with+Redis