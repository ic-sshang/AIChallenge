Purpose and Scope
This document outlines the authentication and error handling strategy for JPMorgan APIs, including Payments and Merchant Screening. It describes how to acquire and manage OAuth tokens, handle 401 Unauthorized responses, classify and respond to API errors, and integrate these strategies into a reusable .NET Core library (
JPMorganApiClient
).
Token generation basics
Token Request
Use the Client Credentials Grant to obtain an access token:
Endpoint:
POST 
https://api.payments.jpmorgan.com/oauth2/token
Headers:
Content-Type: application/x-www-form-urlencoded
Authorization: Basic <Base64(client_id:client_secret)>

Body:
grant_type=client_credentials

Token Response
A successful response should return the JSON in the following format:
{
  "access_token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "Bearer",
  "expires_in": 3600
}

Dealing with 401 unauthorized errors when calling Chase API
To ensure that the OAuth token is generated and cached properly when the call to Chase payments or screening API receives a 401 Unauthorized, you need to:
Detect the 401 in a delegating handler.
Force a token refresh.
Retry the original request with the new token.
Avoid infinite retry loops.
The flow for Unauthorized will look as follows:
Other errors from Chase
J.P. Morgan APIs return:
HTTP status codes (e.g., 400, 401, 403, 500)
Custom error fields in the response body:
json
{
  "responseStatus": "ERROR",
  "responseCode": "E1001",
  "responseMessage": "Invalid card number",
  "hostMessage": "Card number failed Luhn check"
}

Error Handling Strategy
Based on the documentation from Chase, they do have different types of errors we need to handle.
From our services perspective let's classify errors as retriable and non-retriable.
Retriable vs. Non-Retriable Errors
responseCode
Meaning
Retry?
Notes
E1001 
Invalid card number 
❌ 
	Hard decline 
E1002 
Expired card 
❌	
Prompt user to update 
E2001 
Insufficient funds 
❌ 
Inform user 
E3001 
Timeout or network error 
✅ 
Retry with Polly 
E3002 
Internal server error 
✅ 
Retry with backoff 
E4001 
Rate limit exceeded 
✅ 
Retry after delay 
E5001 
Authentication failed 
✅ 
Refresh token and retry 
E6001 
Duplicate transaction 
❌ 
Use idempotency key 
We need to log all the errors and when logging, we do need to log the error code and also provide a meaningful error message based on the code.
User-Friendly Message Mapping
responseCode
User Message
E1001 
"The card number you entered is invalid. Please check and try again." 
E1002 
"Your card has expired. Please use a different card." 
E2001 
"There are insufficient funds in your account. Please try another payment method." 
E3001 
"We’re having trouble connecting. Please try again in a moment." 
E3002 
"Something went wrong on our end. Please try again shortly." 
E4001 
"We’re processing too many requests right now. Please wait and try again." 
E5001 
"Authentication failed. Please refresh and try again." 
E6001 
"This transaction has already been processed." 
We will use Polly to do retries. The algorithm will be as follows:
Check the response code and identify if the error is retriable.
If the error is retriable log that and initiate the retry.
For non-retriable error log the event and throw an exception.
Shared library to incapsulate all of the Chase authentication and error handling logic
To incorporate all of the above we suggest to have a shared library, 
JPMorganApiClient
, which will be responsible for:
Parsing error responses
Determining retriable error codes (e.g., RETRY, INTERNAL_ERROR, E3001, etc.)
Throwing appropriate exceptions
This should allow for:
Consistent authentication and retry behavior across all JPMorgan APIs
Cleaner service-specific handlers
Modular and scalable for future APIs
Suggested implementation for JPMorganApiClient
Authentication.
JPMorganTokenService
 - a place to retrieve and locally persist the access token, and to then allow access to it
c#
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;

namespace JPMorganApiClient.Authentication
{
    public class JPMorganTokenService
    {
        private readonly HttpClient _httpClient;
        private string _accessToken;
        private DateTime _expiresAt;

        public JPMorganTokenService(HttpClient httpClient)
        {
            _httpClient = httpClient;
        }

        public async Task<string> GetAccessTokenAsync()
        {
            if (!string.IsNullOrEmpty(_accessToken) && DateTime.UtcNow < _expiresAt)
                return _accessToken;

            var request = new HttpRequestMessage(HttpMethod.Post, "oauth2/token")
            {
                Content = new FormUrlEncodedContent(new Dictionary<string, string>
                {
                    { "grant_type", "client_credentials" }
                })
            };

            var clientId = "your_client_id";
            var clientSecret = "your_client_secret";
            var authHeader = Convert.ToBase64String(Encoding.UTF8.GetBytes($"{clientId}:{clientSecret}"));
            request.Headers.Authorization = new AuthenticationHeaderValue("Basic", authHeader);

            var response = await _httpClient.SendAsync(request);
            response.EnsureSuccessStatusCode();

            var content = await response.Content.ReadAsStringAsync();
            var token = JsonSerializer.Deserialize<TokenResponse>(content, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });

            _accessToken = token.access_token;
            _expiresAt = DateTime.UtcNow.AddSeconds(token.expires_in - 60);

            return _accessToken;
        }

        public async Task ForceTokenRefreshAsync()
        {
            _accessToken = null;
            _expiresAt = DateTime.MinValue;
            await GetAccessTokenAsync();
        }

        private class TokenResponse
        {
            public string access_token { get; set; }
            public int expires_in { get; set; }
        }
    }
}

AuthenticatedHandler
 - this will try to send the request to Chase and if receiving unauthorized response generate the token and retry the request
c#
using System.Net;
using System.Net.Http.Headers;

namespace JPMorganApiClient.Authentication
{
    public class AuthenticatedHandler : DelegatingHandler
    {
        private readonly JPMorganTokenService _tokenService;

        public AuthenticatedHandler(JPMorganTokenService tokenService)
        {
            _tokenService = tokenService;
        }

        protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
        {
            var originalRequest = await CloneHttpRequestMessageAsync(request);

            request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", await _tokenService.GetAccessTokenAsync());
            var response = await base.SendAsync(request, cancellationToken);

            if (response.StatusCode == HttpStatusCode.Unauthorized)
            {
                await _tokenService.ForceTokenRefreshAsync();
                originalRequest.Headers.Authorization = new AuthenticationHeaderValue("Bearer", await _tokenService.GetAccessTokenAsync());
                response = await base.SendAsync(originalRequest, cancellationToken);
            }

            return response;
        }

        private async Task<HttpRequestMessage> CloneHttpRequestMessageAsync(HttpRequestMessage request)
        {
            var clone = new HttpRequestMessage(request.Method, request.RequestUri)
            {
                Content = request.Content == null ? null : new StreamContent(await request.Content.ReadAsStreamAsync()),
                Version = request.Version
            };

            foreach (var header in request.Headers)
                clone.Headers.TryAddWithoutValidation(header.Key, header.Value);

            foreach (var prop in request.Options)
                clone.Options.TryAdd(prop.Key, prop.Value);

            return clone;
        }
    }
}

Error handling implementation
IApiErrorHandler
 - an interface to abstract the error handling for Chase
c#
namespace JPMorganApiClient.ErrorHandling
{
    public interface IApiErrorHandler
    {
        Task HandleResponseAsync(HttpResponseMessage response);
    }
}
JPMorganErrorHandlerBase
 - the common implementation for error handler which is common for all services:
c#
using System.Text.Json;

namespace JPMorganApiClient.ErrorHandling
{
    public abstract class JPMorganErrorHandlerBase<TError> : IApiErrorHandler
    {
        public async Task HandleResponseAsync(HttpResponseMessage response)
        {
            if (response.IsSuccessStatusCode)
                return;

            var content = await response.Content.ReadAsStringAsync();
            TError error;

            try
            {
                error = JsonSerializer.Deserialize<TError>(content, new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                });
            }
            catch
            {
                throw new ApplicationException($"Unexpected error format: {content}");
            }

            var responseCode = GetResponseCode(error);
            var userMessage = GetUserMessage(responseCode);
            var isRetryable = IsRetryable(responseCode);

            if (isRetryable)
                throw new HttpRequestException($"[Retryable] {userMessage}");

            throw new ApplicationException($"[JPMorgan API] {userMessage}");
        }

        protected abstract string GetResponseCode(TError error);
        protected abstract string GetUserMessage(string code);

        protected virtual bool IsRetryable(string code) => code switch
        {
            "RETRY" => true,
            "INTERNAL_ERROR" => true,
            "E3001" => true,
            "E3002" => true,
            "E4001" => true,
            "E5001" => true,
            _ => false
        };
    }
}
Within 
ICChasePaymentProcessingAPI
 service we will define a custom API error handler using the above base class:
c#
public class PaymentsApiErrorHandler : JPMorganErrorHandlerBase<PaymentsErrorResponse>
{
    protected override string GetResponseCode(PaymentsErrorResponse error) => error?.responseCode;

    protected override string GetUserMessage(string code) => code switch
    {
        "DECLINED" => "The transaction was declined. Please check your payment details.",
        "CONSUMER_ABORTED" => "The transaction was cancelled by the user.",
        "INVALID_MERCHANT" => "The merchant information is invalid.",
        "INVALID_TRANSACTION" => "The transaction format is invalid.",
        "INVALID_AMOUNT" => "The amount is invalid or exceeds limits.",
        "INVALID_ISSUER" => "The card issuer is not supported.",
        "DUPLICATE" => "Duplicate transaction detected.",
        "EXCEEDS_AUTH" => "Transaction exceeds the authorized amount.",
        "STOP_PAYMENT" => "A stop payment order has been issued.",
        "REVOKED_AUTH" => "Authorization has been revoked.",
        "SURCHARGE_NOT_ALLOWED" => "Surcharge not permitted on this card.",
        _ => "An unexpected error occurred. Please try again or contact support."
    };

    protected override bool IsRetryable(string code) => code switch
    {
        "RETRY" => true,
        _ => false
    };

    private class PaymentsErrorResponse
    {
        public string responseStatus { get; set; }
        public string responseCode { get; set; }
        public string responseMessage { get; set; }
        public string hostMessage { get; set; }
    }
}

Common HttpClient
Sample Http client to be provided as part of the library, which can incorporate any custom error handler in it.
c#
using JPMorganApiClient.Authentication;
using JPMorganApiClient.ErrorHandling;
using Microsoft.Extensions.DependencyInjection;
using Polly;
using Polly.Extensions.Http;

namespace JPMorganApiClient.Extensions
{
    public static class JPMorganHttpClientBuilder
    {
        public static IServiceCollection AddJPMorganClient<TErrorHandler>(
            this IServiceCollection services,
            string clientName,
            string baseUrl)
            where TErrorHandler : class, IApiErrorHandler
        {
            services.AddTransient<TErrorHandler>();
            services.AddTransient<AuthenticatedHandler>();

            services.AddHttpClient(clientName, client =>
            {
                client.BaseAddress = new Uri(baseUrl);
            })
            .AddHttpMessageHandler<AuthenticatedHandler>()
            .AddPolicyHandler(GetRetryPolicy())
            .AddPolicyHandler(GetCircuitBreakerPolicy());

            return services;
        }

        private static IAsyncPolicy<HttpResponseMessage> GetRetryPolicy() =>
            HttpPolicyExtensions
                .HandleTransientHttpError()
                .WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));

        private static IAsyncPolicy<HttpResponseMessage> GetCircuitBreakerPolicy() =>
            HttpPolicyExtensions
                .HandleTransientHttpError()
                .CircuitBreakerAsync(5, TimeSpan.FromMinutes(1));
    }
}

Logging and Monitoring
All API responses should be logged with the following fields:
responseCode
responseMessage
hostMessage
Monitoring:
Retry attempts and circuit breaker state
Token refresh events
Alerting on repeated retriable failures
Fallback and Alerting Strategy
If all retries fail or the circuit breaker is open:
Return a 503 Service Unavailable to the caller
Log the failure with correlation ID
Post a respective metric
Extending the JPMorganApiClient Library
To support a new JPMorgan API:
Define a new error model class (e.g., 
DisputesErrorResponse
)
Create a new error handler inheriting from 
JPMorganErrorHandlerBase<T>
Implement 
GetResponseCode()
 and 
GetUserMessage()
 methods
Register the handler using 
AddJPMorganClient<TErrorHandler>()
Testing Strategy
We will use integration tests to validate:
Token caching and refresh behavior
Retry logic on 5xx and 401 responses
Error handler mappings for known response codes
Within unit tests, we will use 
HttpMessageHandler
 mocks to simulate:
401 Unauthorized
Retriable and non-retriable errors
 URL:/spaces/EA/pages/4545282076/JPMorgan+Chase+API+Authentication+and+Error+Handling+Strategy+-+DRAFT