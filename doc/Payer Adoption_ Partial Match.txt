Implementation of N-Gram Filtering +  Levenshtein Distance Algorithm
Source Table (Raw Data)
CREATE TABLE RawRecords (
    Id INT PRIMARY KEY,
    AccountNumber NVARCHAR(100),
    InvoiceNumber NVARCHAR(100),
    Address NVARCHAR(500)
);
Precomputed N-Gram Table
Each searchable field will have its own N-grams stored here
CREATE TABLE NGramIndex (
    RecordId INT,
    FieldName NVARCHAR(50), -- 'AccountNumber', 'InvoiceNumber', 'Address'
    Token NVARCHAR(10),     -- The trigram or bigram
    OriginalValue NVARCHAR(500)
);
N-Gram Generation Procedure                                                                                                                                   
CREATE PROCEDURE PopulateNGrams
AS
BEGIN
    DELETE FROM NGramIndex;
INSERT INTO NGramIndex (RecordId, FieldName, Token, OriginalValue)
SELECT 
    Id, 'AccountNumber', value, AccountNumber
FROM RawRecords
CROSS APPLY dbo.SplitToNGrams(AccountNumber, 3)

UNION ALL

SELECT 
    Id, 'InvoiceNumber', value, InvoiceNumber
FROM RawRecords
CROSS APPLY dbo.SplitToNGrams(InvoiceNumber, 3)

UNION ALL

SELECT 
    Id, 'Address', value, Address
FROM RawRecords
CROSS APPLY dbo.SplitToNGrams(Address, 3);
END
Supporting Function: SplitToNGrams                                                                                                               CREATE FUNCTION SplitToNGrams (
    @input NVARCHAR(MAX),
    @n INT
)
RETURNS @ngrams TABLE (value NVARCHAR(10))
AS
BEGIN
    DECLARE @i INT = 1;
    WHILE @i <= LEN(@input) - @n + 1
    BEGIN
        INSERT INTO @ngrams(value)
        VALUES (SUBSTRING(@input, @i, @n));
        SET @i += 1;
    END
    RETURN;
END
Search Stored Procedure                                                                                                                             CREATE PROCEDURE SearchFuzzy
    @SearchText NVARCHAR(500),
    @FieldName NVARCHAR(50),  -- 'AccountNumber', 'InvoiceNumber', or 'Address'
    @TopN INT = 10
AS
BEGIN
    DECLARE @SearchNGrams TABLE (Token NVARCHAR(10));
    INSERT INTO @SearchNGrams(Token)
    SELECT value FROM dbo.SplitToNGrams(@SearchText, 3);
;WITH MatchScores AS (
    SELECT 
        n.RecordId,
        COUNT(*) AS MatchCount,
        MAX(n.OriginalValue) AS OriginalValue
    FROM NGramIndex n
    INNER JOIN @SearchNGrams s ON n.Token = s.Token
    WHERE n.FieldName = @FieldName
    GROUP BY n.RecordId
)
SELECT TOP (@TopN)
    r.Id,
    r.AccountNumber,
    r.InvoiceNumber,
    r.Address,
    m.MatchCount,
    dbo.Levenshtein(m.OriginalValue, @SearchText) AS LevenshteinScore
FROM MatchScores m
JOIN RawRecords r ON r.Id = m.RecordId
ORDER BY LevenshteinScore ASC, MatchCount DESC;
END
Levenshtein Distance Function                                                                                                                                                                    CREATE FUNCTION Levenshtein(@s NVARCHAR(MAX), @t NVARCHAR(MAX))
RETURNS INT
AS
BEGIN
    DECLARE @sLen INT = LEN(@s),
            @tLen INT = LEN(@t),
            @i INT,
            @j INT,
            @cost INT
DECLARE @d TABLE (i INT, j INT, cost INT)

-- Initialize matrix
INSERT INTO @d(i, j, cost)
SELECT i.i, j.j, 0
FROM (SELECT TOP (@sLen + 1) ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) - 1 AS i FROM sys.all_objects) i,
     (SELECT TOP (@tLen + 1) ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) - 1 AS j FROM sys.all_objects) j

-- Fill in distances
UPDATE @d SET cost = 
    CASE 
        WHEN i = 0 THEN j
        WHEN j = 0 THEN i
        ELSE 0
    END

SET @i = 1
WHILE @i <= @sLen
BEGIN
    SET @j = 1
    WHILE @j <= @tLen
    BEGIN
        SELECT @cost = CASE WHEN SUBSTRING(@s, @i, 1) = SUBSTRING(@t, @j, 1) THEN 0 ELSE 1 END

        UPDATE @d SET cost = (
            SELECT MIN(c1 + 1, c2 + 1, c3 + @cost)
            FROM (
                SELECT cost AS c1 FROM @d WHERE i = @i - 1 AND j = @j
                UNION ALL
                SELECT cost AS c2 FROM @d WHERE i = @i AND j = @j - 1
                UNION ALL
                SELECT cost AS c3 FROM @d WHERE i = @i - 1 AND j = @j - 1
            ) x
        )
        WHERE i = @i AND j = @j

        SET @j = @j + 1
    END
    SET @i = @i + 1
END

DECLARE @result INT
SELECT @result = cost FROM @d WHERE i = @sLen AND j = @tLen
RETURN @result
END
âœ… Summary
ðŸ’¡ Fast due to indexed N-Grams (precomputed)
ðŸŽ¯ Accurate with Levenshtein scoring
ðŸ“¦ Supports multiple fields dynamically
ðŸ§  Can scale to millions of rows
 URL:/spaces/PE/pages/4350869514/Payer+Adoption+Partial+Match