3
3
false
list
false
Single Application per Container
A container is designed to have the same lifecycle as the app it hosts.  The entry point application is what is managed/monitored by the container runtime and kubernetes.  
Having multiple applications hosted in a single container adds complexity and potential lifecycle issues.
PODs
Typically a kubernetes POD should be running a single container.  However, PODs can support multiple containers but this model should be a edge case and require proper review and careful consideration.
Shutdown
Entry point applications should respond to shutdown signals SIGINT and SIGTERM
.  These signals are provided by kubernetes to a container POD to shutdown.
SIGINT is used to request the shutdown of a process
SIGTERM is used to kill a process
Below is a simple class that can be used to handle these signals in a .Net Framework console application that needs to wait for shutdown, like when starting up a WCF service that runs in the background for request  processing.  This should not be used for startup code that runs the processing directly end to end and does not need a wait for shutdown mechanism, ie once the startup code is complete there is no more work.
public class ConsoleService
    {
        System.Threading.ManualResetEvent manualResetEventExit;
        Action startup;
        Action shutdown;

        public ConsoleService()
        {
            startup = null;
            shutdown = null;
            manualResetEventExit = new System.Threading.ManualResetEvent(false);

            Console.CancelKeyPress += (s, e) =>
            {
                e.Cancel = true;
                Console.WriteLine("Received SIGINT");
                manualResetEventExit.Set();
            };

            AppDomain.CurrentDomain.ProcessExit += (s, e) =>
            {
                if (!manualResetEventExit.WaitOne(1))
                {
                    Console.WriteLine("Received SIGTERM");
                    manualResetEventExit.Set();
                }
            };
        }

        public ConsoleService Startup(Action startup)
        {
            this.startup = startup;
            return this;
        }

        public ConsoleService Shutdown(Action shutdown)
        {
            this.shutdown = shutdown;
            return this;
        }

        public void Run()
        {
            if( startup != null )
                startup();

            manualResetEventExit.WaitOne();

            if( shutdown != null)
                shutdown();
        }
    }
Below is a example on how to use it
internal class Program
    {
        static void Main(string[] args)
        {
            ConsoleService consoleService = new ConsoleService();

            consoleService.Startup(() =>
           {
               // some startup work, should not be blocking, it should complete
               Console.WriteLine("Startup");
           });

            consoleService.Shutdown(() =>
            {
                // some shutdown work, it should complete in a reasonable amount of time
                Console.WriteLine("Shutdown");
            });

            consoleService.Run();
        }
    }
Configurations and Settings
Environment specific configuration settings should be provided by Environment Variables. This is how Kubernetes provides settings to Pods on startup.
 
App.Configs and Web.Configs
A configuration builder can be use to pull values from Environment Variables as well as standard .config files.
https://learn.microsoft.com/en-us/dotnet/api/system.configuration.configurationbuilder?view=netframework-4.8
Microsoft has a implementation that does this.
https://www.nuget.org/packages/Microsoft.Configuration.ConfigurationBuilders.Environment/
 
Restricted Secrets
A setting that has been classified as restricted should NOT be in a Environment Variable.   The preferred method, as of this writing, requires the software to access the secret directly from a Azure Key Vault using managed identity and the Azure Key Vault SDK via the 
IC.Azure.KeyVault
 library. 
Logging
Container entry point applications should write logs to the STDOUT and STDERR streams. Kubernetes listens to these steams and writes container logs on the host node. These log files can be shipped to a log aggregator, like New Relic. For Net 4.8 the Console is what is used to write to these streams. If you are using the Serilog via the 
IC.Serilog
 library you can configure it to output to the Console. If you are writing to files directly or to some other log store you should update the code to use the Console.
Local Storage
Container images
 should be considered immutable.   This is done in the kubernetes service image  configuration.  If you need local storage that is persisted a mounted volume can be configured in kubernetes.   This should be avoided where possible as it add complexity to the deployment model.  Consider other options like Azure Blob Storage or a database.
Below is the setting to instruct kubernetes to run the container with a read-only file system.
podSpec.containers.securityContext.readOnlyFilesystem: true
New Relic APM
If the target application is integrated into New Relic APM for monitoring data outside of just application logs then the New Relic dotnet agent should be installed in the container image as part of the docker build.
FROM mcr.microsoft.com/dotnet/framework/aspnet

# Publish your application.
COPY YOUR_APP_TO_BE_PUBLISHED /inetpub/wwwroot

# Download the New Relic .NET agent installer
RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\
 Invoke-WebRequest "https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi"\
 -UseBasicParsing -OutFile "NewRelicDotNetAgent_x64.msi"

# Install the New Relic .NET agent
RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, "NewRelicDotNetAgent_x64.msi", /qn,\
 NR_LICENSE_KEY=INSERT_YOUR_LICENSE_KEY

# Remove the New Relic .NET agent installer
RUN Remove-Item "NewRelicDotNetAgent_x64.msi"

# Set your application name
ENV NEW_RELIC_APP_NAME=INSERT_YOUR_APP_NAME

Environment Variables
You can use  Environment Variables configured for the POD via kubernetes to avoid building values into the images themselves.
NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY
 
NEW_RELIC_APP_NAME=INSERT_YOUR_APP_NAME
Kubernetes WCF Component Diagram 
 URL:/spaces/ED/pages/2779742237/Windows+.Net+Framework+4.8+Application+Containerization+-+NET