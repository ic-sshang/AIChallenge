Managed Identity
Each service has a workload identity.  This workload identity is created by infrastructure as part the setup and configuration of a new service in kubernetes.  We need to formalize the new k8s service request process.  As part of the a new k8s service request we should capture if the service needs access to the global Key Vault and to the database server for that target cluster environment and the appropriate access request service desk tickets should be created at that time.  The work load identity is not owned and typically unknown by software developers.  Incorrect MI assignments have occurred due to this additional middleman process.
IC.ApplicationAuthService
Workload Identity in kubernetes will inject environment variables used to obtain access tokens to access resources via Managed Identity.   The 
Azure.Identity
 library supports 
DefaultAzureCredential
 which will use these environment values if they are present.   The current IC library implementation needs to be updated to use 
DefaultAzureCredential
 when a Client ID is not explicitly passed in by the calling application.  Right now it is using 
ManagedIdentityCredential
 with a empty constructor which does not support the Workload Identity environment variables.   The workaround is having the application manage the Client ID which adds unnecessary configuration when Workload identity is already supported by 
Azure.Identity
 
DefaultAzureCredential
.
https://dev.azure.com/invoicecloud/Src/_git/IC.ApplicationAuthService?path=/IC.ApplicationAuthService/AccessTokenService.cs&version=GBmain&line=93&lineEnd=94&lineStartColumn=1&lineEndColumn=1&lineStyle=plain&_a=contents
Pipelines
We ran into a few issues with the pipelines and not fully understanding the impact whenever there was upcoming changes or improvements. This led to additional engineering toil while developing and testing in a dev environment. Team also hit a few roadblocks with access issues on the pipelines, whether it was having the pipeline have access to certain environments, ADO libraries, etc. Or user permission issues where some members of the team couldn’t kick off the pipeline. 
IC.Database Usage Issues in .Net 6+
There are some behaviors that are problematic:
Infrastructure work in the constructor
Exceptions that occur when a instance is created results in a dependency resolution failure.   A cache is seeded via a database query.  This query can fail and results in a failed instance being created.
https://dev.azure.com/invoicecloud/Src/_git/ICDatabaseService?path=/IC.Database/Databases/Framework/EnvironmentDB.vb&version=GBmain&line=94&lineEnd=95&lineStartColumn=1&lineEndColumn=1&lineStyle=plain&_a=contents
Internal caching of database data, background timer
A background timer resource is created to manage a cache regardless if the application needs the cached data.
https://dev.azure.com/invoicecloud/Src/_git/ICDatabaseService?path=/IC.Database/Databases/Framework/EnvironmentDB.vb&version=GBmain&line=102&lineEnd=103&lineStartColumn=1&lineEndColumn=1&lineStyle=plain&_a=contents
Data Types
The library was designed to return loosely coupled data types DataRow, DataTable, and DataSet.  Strongly typed data binding is the preferred approach and avoids indexer errors and the additional mapping to .Net data models.
Stored Procedure Interface
The interface to execute stored procedure with parameters is awkward, typed arrays of strings, integers etc…
Developer Experience
The developer is required to know a lot of IC specific ways of doing things.  These things tend to differ significantly from best practices.  We need to separate our new code from the existing libraries.  If we find ourselves needing the functionality provided by some library, we need to consider what the underlying requirements are and if those actually justify being a library.  Given the broadness of functionality in many existing libraries, it’s likely we will only be looking at a subset of that functionality to be carried over.  Most of the existing libraries that we’ve encountered so far structured in a way that makes them difficult to use with dependency injection and have required a sub-optimal intermediary layer that we have to create.  We want to build these with a testable, injectable structure from the ground up.
IC.Database
This library in particular has been a problem.  It required a complex wrapper to be dependency injectable.  It was less of a problem in the 
ASP.Net
 classic world (where MyIIS lives) where every web request gets served by a dedicated thread that has it’s own isolated copy of static classes.  In the .net 6+ world, many requests run on the same thread as it is vastly more efficient. This makes the static nature of IC.Database problematic as we need to take extra care to ensure different requests don’t interfere with each other.  Additionally we have to manage mapping database primitives, like DataRows and DataTables to domain objects.  Under the covers the library is unavoidably doing unnecessary work every time we get a request, like pre-caching the master biller data.  Numerous mature ORMs exist that could do 90% of the work IC.Database does but better and easier.  Additionally they can do many things that IC.Database will never be able to do without substantial effort, like connecting to a database that’s not one of our deployed Azure instances.
IC.Logins
This library has also been a problem.  It contains duplicates of many legacy libraries (clsBillers, clsUtilities, etc..).  It also relies on a static pointer to a dataproxy which is not threadsafe and forces the library to be used as a singleton.  Although there are unit test projects, these projects do not actually work with MI and use connection strings instead.  We’ve been forced to create a factory wrapper in order to shoehorn this library into NextGen and make it injectable.  We only use about 10 lines of code from this library.  We should either stop using it or do a complete re-write.
Lack of Isolation
Because of IC.Database, we can only work with our deployed Azure DBs and we can only connect to those from the term servers.  This means we can’t run isolated integration tests or even have meaningful feedback from the tests we’re building now that run against the deployed database as we have no way of preventing data from being changed under our feet.  It’s very easy to happen if the tests are being run in different places at the same time, for instance if two agents are running the same pipeline.  You also can’t prevent anyone from going into any part of the UI (Biller Portal, Payer Portal, Virtual Sites or ORM) and fouling the data while a test is running.
Lack of Developer Trust
We don’t have admin on our own machines because of amorphous security fears.  This means we couldn’t do something like run the database(s) locally in a Docker container.  Doing that would give us the isolation we need to work completely isolated from any deployed environment.  This in turn would mean we would not need to worry about connecting to term servers or jump boxes or any other silly intermediary to do our day to day work.
Lack of Empowerment
The team comprises senior engineers that bring outside expertise in order to develop a next generation system.  However, almost all technology decisions are externally mandated.  The team is not empowered to make its own decisions, yet is held accountable for those mandated decisions.
Term Servers
Or any other solution that requires remoting to do normal work.  It’s vastly better security to have developers doing most of the work while not connected to any deployed assets.  From the developers point of view, working in the remote desktops is hobbling productivity.  Any solution that requires developers to connect to a remote desktop to do their work not good enough.
 URL:/spaces/EN/pages/2658762983/Areas+Where+We+Can+Improve