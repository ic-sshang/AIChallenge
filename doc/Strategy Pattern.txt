Overview
The 
Strategy Design Pattern
 is a 
behavioral
 design pattern which abstracts an algorithms implementation from its definition. To put it more simply, it allows similar, yet distinct, behavior to be invoked from a common interface at runtime.
The Strategy pattern calls for separating independent behavior (algorithms) into different “strategies” (read files) that can be invoked dynamically at runtime - these strategies all inherit from a single interface (e.g. 
IStrategy
) that encapsulates behavior behind a set of common properties and/or methods.
Why It is Useful
The strategy pattern provides an easy way to invoke behavior dynamically in an OOP-manner without defaulting to procedural-style 
switch
 or 
if-else
 control flow - while this behavior can still typically exist in a factory or some other method responsible for picking the correct strategy, it is hidden from the caller & can be easily and cleanly unit tested.
When To Use It
Consider a scenario when you have something like this:
c#
switch(reportType) {
  case ReportType.MonthlyReport:
      // Do Stuff
      break;
  case ReportType.WeeklyReport:
      // Do Stuff
      break;
  case ReportType.DailyReport:
      // Do Stuff
      break;
}
The 
// Do Stuff
 blocks above may be simple, like calling an external service - or they may be more complicated and have full implementations directly in the 
switch
 or method callbacks that are invoked. Often, these types of constructs are also nested within other, larger methods - making them more difficult to isolate & test.
Imagine that you have a requirement to now add 5 new report types - all of which are more or less just variations on the same pattern:
DecadeReport
YearlyReport
SemiAnnualReport
QuarterlyReport
HourlyReport
Let’s make some assumptions at this point:
These reports are more complicated than just having a different set of date range criteria - each report has different columns included, different formatting, different output values, and different methods of numerical aggregation.
 
Do note, that if the situation were as simple as a date-range variance, that would NOT be an appropriate scenario for the strategy pattern.
In the above example, 
// Do Stuff
 is either making calls to various different services or handlers for each report type - or the actual code for each scenario is directly within the 
switch/case
 block.
The immediately obvious answer to address our new report types would be to continue adding 
enum
 values & add those as 
case
 values into the larger 
switch
 statement.
c#
switch(reportType) {
  case ReportType.DecadeReport:
      // Do Stuff
      break;
  case ReportType.YearlyReport:
      // Do Stuff
      break;
  case ReportType.SemiAnnualReport:
      // Do Stuff
      break;
  case ReportType.QuarterlyReport:
      // Do Stuff
      break;
  case ReportType.MonthlyReport:
      // Do Stuff
      break;
  case ReportType.WeeklyReport:
      // Do Stuff
      break;
  case ReportType.DailyReport:
      // Do Stuff
      break;
  case ReportType.HourlyReport:
      // Do Stuff
      break;
}
Does that technically fulfill the requirements of the problem? Yes, it does.
But consider the following:
We’ve now got a 
switch
 statement that has 8 independent possible branches of logic that will be executed based on whatever the caller is supplying as a report type - if this 
switch
 statement is nested inside of a larger method, then the complexity of the method increases dramatically.
We have a possibly non-deterministic number of items that may be necessary options. Maybe in 6-months there will be an additional 10 report types, including 3 or 4 custom reports for only a small subset of customers.
Example
To implement the strategy pattern - we’ll create a common interface that all the various reporting strategies can implement.
note
Note that our reporting example could very obviously just be handled with regular date range filtering - humor me, here.


Note that our reporting example could very obviously just be handled with regular date range filtering - humor me, here.


c#
public interface IReportStrategy {
  void RunReport();
}

public WeeklyReportStrategy: IReportStrategy {
  public void RunReport() {}
}

public DailyReportStrategy: IReportStrategy {
  public void RunReport() {}
}

// etc.
Then we can use our strategies in a downstream caller
c#
public interface IReportStrategyContext {
  void SetStrategy(IStrategy reportingStrategy);
  void RunReport();
}

public class ReportStrategyContext: IReportStrategyContext {
  private readonly IReportStrategy _reportingStrategy

  public void SetStrategy(IReportStrategy reportingStrategy) {
    this._reportingStrategy = reportingStrategy;
  }

  public void RunReport() {
    this._reportingStrategy.RunReport();
  }
}

public class ReportRunner {
  // Note - this type of thing is better done with an abstract factory.
  // and it more appropriately belongs in the context, not here on the ReportRunner
  private readonly Dictionary<ReportType, IReportStrategy> _strategies = new {
    { ReportType.Weekly, new WeeklyReportStrategy() },
    { ReportType.Daily, new DailyReportStrategy() },
    // etc.
  };
  
  private readonly IReportStrategyContext _context;
  public ReportRunner(IReportStrategyContext context) {
    this._context = context;
  }

  public void RunSelectedReport(ReportType report) {
    if(this._strategies.TryGetValue(report, out var strategy)) {
        this._context.SetStrategy(strategy);
        this._context.RunReport();
    } else {
        throw new ReportStrategyNotFoundException();
    }
  }
}
In the pseudo-code above, we have created a single interface, 
IReportStrategy
 which can be implemented by all concerned 
ReportStrategy
 types.
Then we create a layer of abstraction between the strategies and the consumer by implementing a 
ReportStrategyContext
 - alternatively,  this object could also implement factory behavior that would allow it to more dynamically select strategies internally vs needing one passed to it.
Lastly, in the caller, we inject the 
IReportStrategyContext
 and only execute the strategies using this object as a proxy. The behavior is standardized behind a common interface definition, exposing only 
RunReport()
 for the action and 
SetStrategy(IReportingStrategy)
 to allow the modification of the active strategy at runtime.
Benefits
The overall benefit of the strategy pattern is to allow your code to more dynamically change its behavior at run time in an object-oriented manner.
Since each algorithm is extracted into its own 
Strategy
 object - each one can be independently tested, and more importantly, there is no longer a need to test each individual 
switch/case
 possibility in a central method - now 
IStrategyContext
 or 
IStrategy
 can be mocked, and we can control or disregard its behavior when testing the consumer.
While code still must be added/removed when things change - this now becomes a less intrusive, more isolated change - i.e. 
Extensible
. Given the above example, new report types can be created as independent objects without touching the original calling consumer code - they can also be tested without needing to modify the consumer’s test cases and they should also keep the codebase + tests more stable when a modification is needed.
Disadvantages
More files to maintain - since we’ve moved away from a procedural style of execution to a more object-oriented one, we will need additional class objects.
Adds an additional layer of abstraction - you can see in the above example; we need to have some sort of 
Context
 that abstracts away our strategies and allows for them to be dynamically invoked by a caller - this can be made more robust by adding an abstract factory that more easily selects a particular 
IStrategy
 given one of the 
ReportType
 values. This is more code to test, more objects that are created - but generally the overhead of this is negligible.
For simple tasks, can be overkill. It is easy to see how this can replace a lot of different branching logic - 
if/else
, 
switch
, etc. However, it may be way overkill for the task at hand - this may actually end up being a detriment in scenarios where there isn’t a large need for more dynamic behavior.
References
Strategy
Strategy Pattern | Object Oriented Design
 URL:/spaces/EA/pages/4138008604/Strategy+Pattern