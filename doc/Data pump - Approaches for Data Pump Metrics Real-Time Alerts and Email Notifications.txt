Purpose
This document outlines various approaches to implement real-time alerts and Email notifications when a new record is inserted into an SQL table and meets a certain threshold. 
Approaches:
Approach 1 — Using SQL Triggers and Stored Procedures to call Webhooks or Azure Service Bus for real time alerts
Using SQL Triggers and Stored Procedures to call Webhooks or Azure Service Bus for real-time alerts involves setting up SQL triggers to automatically execute stored procedures when specific database events occur. These stored procedures can then send HTTP requests to webhooks or publish messages to Azure Service Bus, enabling immediate notifications and actions based on database changes. This method is useful for applications that need instant responses to data updates, such as monitoring systems and automated workflows.
1. Create a SQL Trigger on the Table
The trigger watches INSERT operations and checks if the inserted record exceeds the threshold.
2. Create a Webhook Endpoint
:
Create a new Asp dotnet core Web API project in .NET 8 to receive webhook payloads.
Once webhook receives request, it will send the email and alerts.
3. Create a Stored Procedure to call a webhook
Stored procedure should send the alert. This stored procedure will either:
Call an 
HTTPS endpoint
 (Webhook) 
Example: If simple, you can use 
sp_invoke_external_rest_endpoint
 (in Azure SQL) to call an HTTP webhook.
Example for calling a webhook:
CREATE OR ALTER PROCEDURE SendAlertWebhook
    @Temperature FLOAT
AS
BEGIN
    DECLARE @body NVARCHAR(MAX) = N'{
        "alert": "Threshold exceeded",
        "value": ' + CAST(@Temperature AS NVARCHAR) + '
    }'

    EXEC sp_invoke_external_rest_endpoint  
        @url = N'https://your-webhook-url.com/alert',  
        @payload = @body,  
        @method = 'POST',  
        @headers = '{"Content-Type":"application/json"}'
END

 
Note:
 
sp_invoke_external_rest_endpoint
 needs to be enabled on Azure SQL.
If you are 
on-premise
, you might need to use SQL CLR or push into a Service Bus through an external app.
Workflow
INSERT INTO SensorData
        ↓
SQL Trigger (AFTER INSERT)
        ↓
Stored Procedure (SendAlertWebhook)
        ↓
Webhook or Service Bus
        ↓
Alert Notification Sent

 
Using Azure Service Bus Instead of Direct Webhook
Steps:
Set Up Azure Service Bus
:
Create a Service Bus namespace and a queue in Azure.
Create a Webhook Endpoint
:
Create a new Asp dotnet core  Web API project in .NET 8 to receive webhook payloads. 
Deploy the web service to a platform like Azure App Service.
Configure Azure Function
:
Create an Azure Function with an HTTPs trigger.
Modify the function to send messages to the webhook endpoint.
 Security and Performance Considerations
Triggers 
slow down
 the insert operation.
Directly invoking external endpoints requires careful management of credentials and permissions to prevent unauthorized access.
Ideally push messages into a 
Service Bus
 queue rather than directly call webhooks.
Deadlock risk:
 avoid triggers doing long operations.
Retry/Failure:
 If the webhook fails, you might want a retry mechanism (Service Bus is better for this).
Approach 2 — Using Azure Logic App to Monitor SQL and Send Email
Using Azure Logic App to Monitor SQL and Send Email. The Logic App triggers for every 'x' minutes polling on the SQL table. If the condition is met the Azure Logic App then sends the request to the dot net console app which sends email.
Create and Deploy an Azure Logic App
Go to Azure Portal ➔ Create a new 
Logic App (Consumption)
.
Design the Logic App Workflow
:
Trigger
: Add a 
Recurrence trigger
 (every X minutes).
Action 1
: Add 
SQL Server Connector
 ➔ 
Execute a query on multiple shards
:
SELECT * FROM MetricData WHERE value> 80

Action 2
: Add a 
Condition
: If query result has rows, then proceed.
Action 3
: 
Send Email
 using:
SendGrid Connector 
Outlook SMTP.
A console app which sends the email.
Configure Connection Strings and Secrets
Set SQL connection, SendGrid API key, etc., securely via 
Azure Key Vault
 or 
Logic App settings
.
Test
Insert a record in the MetricTable➔ Wait for Logic App to poll ➔ Email is sent if threshold exceeded.
[MetricData Table]
      ↓ (Poll every X min)
[Azure Logic App]
      ↓ (Check if Value > Threshold)
[If yes ➔ SendGrid / SMTP Send Email/.net console app]

Approach 3 — Using SQL Server Database Mail (Built-In Email Service)
Using SQL Server Database Mail, you can send email notifications directly from your SQL Server database. This built-in service allows us to configure and send emails. We will use a trigger to check the insert on the desired SQL table, if the threshold value is more, it automatically calls the stored procedure and the stored proc will send mail.
Enable Database Mail in SQL Server
Go to SQL Server Management Studio ➔ Configure 
Database Mail
 wizard.
Provide SMTP server settings (Gmail, SendGrid, Office365, etc.).
Create a Database Mail Profile
E.g., profile name = 
AlertProfile
.
Create a Stored Procedure
Example Stored Procedure:
CREATE PROCEDURE SendThresholdAlert
    @Metricvalue Int
AS
BEGIN
    IF @Metricvalue> 80
    BEGIN
        EXEC msdb.dbo.sp_send_dbmail
            @profile_name = 'AlertProfile',
            @recipients = 'admin@example.com',
            @subject = 'Metricvalue Alert',
            @body = 'Metricvalue threshold exceeded: ' + CAST(@Metricvalue AS NVARCHAR);
    END
END

Call the Procedure
From a Trigger, whenever a record is inserted/updated.
Monitor Database Mail Status
Check mail queues and logs inside SQL Server (
msdb.dbo.sysmail_allitems
).
Workflow
[SensorData Insert/Update]
      ↓ (Trigger/Procedure)
[sp_send_dbmail]
      ↓
[SMTP Server]
      ↓
[Email Sent]

Approach 4 — Build a Dot Net8 Background Cron Job Polling SQL Table
Create a .NET Background Cron Job
Use 
C#
 + 
EF Core
 to connect to your SQL Database.
we may Containerize this
Connect to SQL Server
Setup connection string in appsettings.json or environment variables.
Write Query Logic
Periodically query:
SELECT * FROM MetricValue WHERE Value> 80

Send Emails
Use 
SendGrid
, 
SMTP
, or any email library (e.g., 
MailKit
, 
System.Net.Mail
).
Send email when threshold breaches detected.
ICFramework.Utilities.Email
 we are using this repo to send emails across our solutions we can leverage this for the email processing
Host the App
Host it in:
Azure App Service (WebJob),
Azure Container Instance
Kubernetes CronJob.
Schedule Timer
Inside the app, run a timer that executes the polling every X minutes.
Workflow
[Timer Trigger in Cron JOb] (every X min)
      ↓
[Query MetricData Table for Threshold Breach]
      ↓
[If results ➔ Send Email via SMTP/SendGrid]

Approach 5 — Using Service Broker and SQL Dependency with Dot Net Worker App 
Elastic Job Triggers Stored Procedure
The Elastic Job Agent or another scheduling service runs 
sp_insDataPumpMetricAggregations
on each shard.
Stored Procedure Evaluates Conditions for the computed metrics
After computing all the metrics, the Condition is checked for three metric conditions if the threshold limit is breached or not.
If a condition is met (a metric exceeds a threshold), inserts the data into a new table called PendingAlerts
Alert Message is Inserted into PendingAlerts Table in the Central Shard
The stored procedure inserts the data into PendingAlerts Table in the Central Shard.
Dot NET Listener Receives and Processes Alert
A .NET workerapp continuously listens to this PendingAlerts Table.
Upon receiving a message, it sends an email to the relevant biller.
SQL Setup for Service Broker Queue
Step 1: Enable Service Broker
Ensure Service Broker is enabled for your database:
sql
ALTER DATABASE YourDatabaseName SET ENABLE_BROKER WITH ROLLBACK IMMEDIATE;

Step 2: Create Service Broker Infrastructure
sql
-- Message type
CREATE MESSAGE TYPE [AlertMessage]
VALIDATION = WELL_FORMED_XML;

-- Contract
CREATE CONTRACT [AlertContract]
([AlertMessage] SENT BY INITIATOR);

-- Queue
CREATE QUEUE [AlertQueue];

-- Service
CREATE SERVICE [AlertService]
ON QUEUE [AlertQueue]
([AlertContract]);

Step 3: Checks if the condition is met for sending alerts.
This procedure sends XML alert messages to the Service Broker queue:
sql
--In the InsDataPumpMetricAggregation sp
If @value > ThresholdValue
BEGIN
--Inserts Data into Pending Alerts Table
END

Workflow :
Elastic Job Agent
     |
     |-- (1) Triggers `sp_insDataPumpMetricAggregations` on each shard
     |
     |-- (2) SP evaluates condition
               |
               |inserts into PendingAlerts table
     |
     |-- (4) Message enters `PendingAlertsTable` on the central shard
     |
     |-- (5) .NET worker app running continuously reads the queue
               |
               |-- Parses alert
               |-- Sends email
               |-- Logs result in `ProcessedAlerts` (optional but recommended)


Dot Net Console Application for Email Processing 
Overview
The .NET 8 console application is designed to listen to events from Azure Service Bus or webhooks or listens to service Broker Queue in SQL, process incoming requests, and send emails using the 
ICFramework.Utilities.Email
 library.
Components
Azure Service Bus Listener
:
Setup
: Configure the application to connect to Azure Service Bus.
Listening
: Implement logic to continuously listen for messages.
Processing
: Define how to handle incoming messages.
Webhook Listener
:
Setup
: Configure the application to accept HTTP requests (webhooks).
Listening
: Implement logic to handle incoming HTTP requests.
Processing
: Define how to handle incoming webhook data.
Email Processing
:
Library Integration
: Integrate 
ICFramework.Utilities.Email
 for email sending.
Email Templates
: Define templates for different types of emails.
Sending Emails
: Implement logic to send emails based on processed requests.
Implementation Steps
Project Setup
:
Create a new .NET 8 console application project.
Add Necessary NuGet Packages
:
Add packages for Azure Service Bus, HTTP server, and the email utility.
Configure Azure Service Bus Listener
:
Create a class to handle Azure Service Bus connections and message processing.
Configure Webhook Listener
:
Create a class to handle incoming HTTP requests.
Implement Email Processor
:
Create a class to handle email sending using 
ICFramework.Utilities.Email
.
Long Term Approach using OTEL + Prometheus
Configure OpenTelemetry in .NET
 to collect and expose metrics via a Prometheus endpoint.
Set up Prometheus
 to scrape metrics from the .NET application's exposed 
/metrics
 endpoint.
Create alerting rules in Prometheus
 using threshold-based expressions on collected metrics.
Configure Alertmanager
 to receive alerts from Prometheus and send notifications (email, Slack, etc.).
Connect Prometheus to Alertmanager
 by specifying Alert manager’s address in Prometheus config.
(Optional) Use Grafana
 to visualize metrics and manage alerts in a more user-friendly UI.
Alertmanager matches the alert
 to a route based on its labels (like 
severity
).
The route sends the alert to a webhook receiver
, which you define in 
alertmanager.yml
.
The webhook receiver
 forwards the alert to your custom service or tool.
Your custom webhook service handles the alert
 (e.g., formats it and sends an email using SMTP or an email API).
ICFramework.Utilities.Email
 we are using this repo to send emails across our solutions we can leverage this for the email processing.
The content by label feature automatically displays related articles based on labels you choose. To edit options for this feature, select the placeholder and tap the pencil icon.
false
5
com.atlassian.confluence.content.render.xhtml.model.resource.identifiers.SpaceResourceIdentifier@9f5
modified
false
true
page
kb-how-to-article
label = "kb-how-to-article" and type = "page" and space = "PE"
 URL:/spaces/PE/pages/4201021471/Data+pump+-+Approaches+for+Data+Pump+Metrics+Real-Time+Alerts+and+Email+Notifications