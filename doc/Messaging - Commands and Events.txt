Best Practices
Correlation
One of the benefits of an event-driven system - whether using an event-sourced persistence mechanism or driving service behavior through event reactivity - is the ability to correlate commands/requests and resulting events end-to-end. As the system grows, this will begin to provide complete traces of operations from start to finish and often can be used with external tooling to produce visuals, enable robust troubleshooting, and highlight problematic areas.
note
As a convention, each command or event should have a 
CorrelationId
 property that will be set at the time of command origination and will be subsequently attached to each event that occurs as a result of the command’s execution. This 
CorrelationId
 
should be unique - if in doubt, use a UUID or 
Guid
 
datatype when setting this value manually.
e.g.
public string CorrelationId { get; init; }


As a convention, each command or event should have a 
CorrelationId
 property that will be set at the time of command origination and will be subsequently attached to each event that occurs as a result of the command’s execution. This 
CorrelationId
 
should be unique - if in doubt, use a UUID or 
Guid
 
datatype when setting this value manually.
e.g.
public string CorrelationId { get; init; }


Immutability
Commands and Events should both be 
immutable
. Once they have been created, they should never change. Even when using event-sourced persistence - events should be undone with a compensating event rather than explicit removal.
Note - we are using .NET Standard 2.0 libraries for messages that are to be published externally. The 
record
 
type is not available in C# versions supported by .NET Standard 2.0 - in that case, a 
class
 is perfectly appropriate to use.
For libraries that CAN be published as .NET 8.0 SDKs, 
record
 is still the preferred object type for its immutability and out-of-the-box value-type comparison behavior.
For this reason, it is preferred to use the C# 
record
 type for each command and event. 
Records were introduced in C# 9.0
 and provide an easy way to create immutable data structures with out-of-the-box value type comparison.
There are two specific usages of 
record
 that are acceptable for this case
public record MyRecord
 or 
public record class MyRecord
public readonly record struct MyRecord
The former will produce an immutable reference type, while the latter produces an immutable value type. Either is acceptable, with 
readonly record struct
 being slightly preferred over the former. Regular 
record
 types behave more like a normal 
class
 which may make them preferable for some scenarios.
c#
// Example of simple records using inline constructor syntax.

// immutable struct-type record
public readonly record struct CreateUser(string CorrelationId, Guid UserId, string Email);
// or
// immutable class-type record
public record CreateUser(string CorrelationId, Guid UserId, string Email);
var createUserCommand = new CreateUser($"{Guid.NewGuid()}", Guid.NewGuid(), "me@example.com");

// Example of a more class-like declaration of a record.
// This behaves exactly the same as above.
public record CreateUser {

  public string CorrelationId {get; init;}
  public Guid UserId {get; init;}
  public string Email {get; init;}
  
  /// <summary>
  ///   Default constructor.
  /// </summary>  
  public CreateUser(string correlationId, Guid userId, string email)
      => (CorrelationId, UserId, Email) = (correlationId, userId, email);
}
Right-Sizing
When it comes to messages, think small. Anything placed on a message broker should strive to have the smallest possible memory footprint. Typically, messages should only contain values necessary to perform some type of work downstream of the origination point. For example, you can easily look up a Biller using an ID value - it’s unlikely you would also need to include other identifying information if it isn’t intended to be or hasn’t been modified in some way.
This is both for information-hiding purposes and to ensure the highest throughput and lowest latency possible when using a message broker.
Here are the out-of-the-box message size limits for several common messaging services:
Message Broker
Message Size Limit
Azure Service Bus
256Kb - Standard
1Mb - Premium (unless using 
AMQP
)
Azure Event Hubs
256Kb - Basic
1Mb - Standard
1Mb - Premium
Apache Kafka
1Mb - Default
More on Message Broker Limitations
Microsoft Azure Service Bus quotas and limits - Azure Service Bus | Microsoft Learn
Quotas and limits - Azure Event Hubs - Azure Event Hubs | Microsoft Learn
Apache Kafka Message Size Limit: Best Practices & Config Guide
Naming Guidelines
Moved Here
Commands
Commands tell a service 
to do something
. When designing commands, they should be 
reflective of the business process being performed
. Commands are just regular objects that can be represented through HTTP request payloads sent to an API, produced internally based on an external request, or even created as a reaction to a downstream event occurring.
For example, in a simple reporting system, an end user may run a report, delete a report, create a new report template, or modify an existing report template. 
Important:
 With the exception of 
Create
, 
CRUD language should be specifically avoided when modeling commands.  Naming should reflect 
business process
 - while CRUD behavior still exists under the covers - the point of this in the long-term is to develop a 
Ubiquitous Language
 
that is comprehensible by both technical and non-technical resources.
Example of coarse-grained commands for the above operations:
RunReport
RemoveReport
 
CreateNewReportTemplate
ModifyReportTemplate
Example of fine-grained commands for the above operations:
RunMonthlyRevenueReportForBiller
RemoveReportFromBillerAccount
CreateNewReportTemplateForBiller
ModifyReportTemplateForBiller
There is no global, prescriptive guidance on how granular commands should be - they should be modeled on a case-by-case basis. It should be understood and accepted that commands can evolve and change over time as business needs or requirements change. In general, it is better to be 
more
 
specific
 when possible and use commands to communicate 
exactly
 
what should occur
 - this is preferred to creating overly broad commands that attempt to handle multiple-use cases internally.
Using the same example as above, if there are twenty report types across multiple subsystems (biller, payer, etc.) with different parameters, create a command per report - this also means an API POST endpoint for each. 
Commands should be kept relatively lightweight and not include too much information - just enough to do some downstream work. 
Commands can include collections of values, object-types, etc. - however, beyond Id values necessary for lookups, do not include any sensitive data in commands - no SQL Statements, Azure Resource Names, etc. These are all things that should be derived server-side. 
c#
// (Bad) Example of a coarse-grained command.
/* 
* Note that this command is doing TOO much.
*
* It is highly likely that you would need to perform additional logic internally
* to determine how to even route this command appropriately.
**/
public record RunReport(Guid CommandId, 
                        ReportType ReportType, 
                        ReportingSubsystem ReportingSubsystem,
                        ReportFormat ReportFormat,
                        int? billerId = null,
                        int? payerId = null,
                        int? reportId? = null);

// Better Example of a fine-grained command.
/*
* This command has reduced the noise, removed unnecessary properties,
* and specifically communicates both the report type & reporting subsystem (biller)
* directly in the command name. This leaves 0 room for ambiguity and communicates
* exactly what should happen upon execution.
**/
public record RunMonthlyRevenueReportForBiller(Guid CommandId, 
                                               Guid BillerId, 
                                               ReportFormat? ReportFormat = ReportFormat.CSV);
                                               
Events
Events are emitted by services (or sometimes system components) to indicate that 
something has happened
. Events should always be past tense and describe what has happened.
Events will typically contain data that indicates what was operated upon and what changed. They could also include the results of a particular operation that occurred as the result of a command.
Using the same examples as above, read the following as:
Command
 → 
Event
Coarse-grained
RunReport
 → 
ReportCompleted
RemoveReport
 → 
ReportRemoved
CreateReportTemplate
 → 
ReportTemplateCreated
ModifyReportTemplate
 → 
ReportTemplateModified
Fine-grained
RunMonthlyRevenueReportForBiller
 → 
BillerMonthlyRevenueReportCompleted
RemoveReportFromBillerAccount
 → 
ReportRemovedFromBillerAccount
CreateReportTemplateForBiller
 → 
ReportTemplateCreatedForBiller
ModifyReportTemplateForBiller
 → 
BillerReportTemplateModified
Best Practices for Events
Include audit properties - 
CorrelationId
, 
Timestamp
 and 
Username
.
CorrelationId
 = Identical to the value set on the originating 
Command
. This correlates the event back to its initiator.
Timestamp
 = The time the event occurred. This can be set whenever the event is created. 
It is best practice to use 
DateTime.UtcNow
 and convert to local time on the client. UTC dates make it easier to work with customers distributed across the world.
Username
 = The name of the resource who executed the initial 
Command
. In some cases, this may need to be derived internally and sent over the bus with the originating 
Command
 - it can be derived from the 
IHttpContext
.
Many events are intended 
to be reacted to 
- if there were data a downstream consumer would need to know, include it in the event. 
For instance, if there is a downstream audit service that needs to log whenever a customer’s name changes - it may be a better idea to just track the before/after values for the Name rather than making it a necessity to look that data up from the database downstream.
Example - Finer Granularity of Events and CRUD comparison
I want to focus specifically on one command + event combination - 
ModifyReportTemplateForBiller
. While this is a perfectly acceptable command as it currently stands - this is a really great example of a command where 
multiple
 events can be emitted as a result of its execution.
As a simple example - maybe the existing reporting system has 3 main sections for an existing template
Header
Body
Footer
From a web/UI perspective, these three sections are all posted to the API at once, rather than independent of one another. As a brief aside, this is a common scenario and can typically be addressed 
by making the UI/workflow more task-based
. However, for the sake of example - we just have the one ‘Submit’ button on this page and we’ll get all three of those sections in the API request/command.
For the sake of example, let’s model the command like so:
c#
public record ModifyReportTemplateForBiller(string CorrelationId, 
                                            Guid BillerId, 
                                            Guid ReportTemplateId,
                                            // Three sections represented as other record types.
                                            ReportHeader Header,
                                            ReportBody Body,
                                            ReportFooter Footer);
This command may just be a direct request that is sent to an API POST endpoint - once it arrives in the API, perhaps there is some validation performed, the biller & template may both need to be loaded through a service-layer. etc.
Example of one potential event type - the others would be virtually identical in this scenario.
c#
public record ReportTemplateHeaderChangedForBiller {

   // This is the original correlation Id from the command.
   // Now we've associated the result of the command to its origination point.
   public string CorrelationId { get; init; }
   
   public Guid BillerId { get; init; }
   
   public Guid ReportTemplateId { get; init; }
   
   /* TimeStamp + Username are audit properties
    * Indicating who performed the action and when
    **/
   
   public string Username { get; init; }
   
   public DateTime TimeStamp { get; init; }
   
   public ReportTemplateChangedForBiller(Guid correlationId, Guid billerId, Guid reportTemplateId, string userName) 
      => (CorrelationId, BillerId, ReportTemplateId, Username, Timestamp) = (correlationId, reportTemplateId, userName, DateTime.UtcNow);
}
In an event-sourced system using aggregates - some of these activities would occur directly in the domain model & events would be emitted upon saving the aggregate - however, this behavior could also be represented through a regular service:
c#
// Simple example
public async Task ModifyReportTemplate(ModifyReportTemplateForBiller command, CancellationToken stoppingToken) {
  // Propagate asynchronous cancellation.
  stoppingToken.ThrowIfCancellationRequested();
  
  // Fetch the existing template using the Id values provided in the command.
  var existingTemplate = await this._reporting.GetReportTemplateForBiller(command.BillerId, command.ReportTemplateId, stoppingToken);
  
  // Perform some checks on the template & determine what needs updated.
  
  // This out-of-the-box comparison is part of the magic of the 'record' type
  if(existingTemplate.Header.Equals(command.Header)) {
    await this._eventBus.Publish(new ReportTemplateHeaderChangedForBiller());
  }
  
  if(existingTemplate.Body.Equals(command.Body)) {
    await this._eventBus.Publish(new ReportTemplateBodyChangedForBiller());
  }
  
  if(existingTemplate.Footer.Equals(command.Footer)) {
    await this._eventBus.Publish(new ReportTemplateFooterChangedForBiller());
  }

}
Note in the above example there are 3 potential events that can be emitted as a result of this command.
Let’s use CRUD-based language side-by-side and see which style gives us a better view into business process & system behavior.
Event Driven
CRUD-based
ReportTemplateCreatedForBiller
ReportTemplateInserted
ReportTemplateHeaderChangedForBiller
ReportTemplateUpdated
ReportTemplateBodyChangedForBiller
ReportTemplateUpdated
ReportTemplateFooterChangedForBiller
ReportTemplateUpdated
ReportTemplateHeaderChangedForBiller
ReportTemplateUpdated
ReportTemplateHeaderChangedForBiller
ReportTemplateUpdated
ReportRemovedFromBiller
ReportDeleted
ReportTemplateRemovedFromBiller
ReportTemplateDeleted
 URL:/spaces/EA/pages/4112285799/Messaging+-+Commands+and+Events