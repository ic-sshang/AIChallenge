none
Questions/Thoughts
1. Adding React incrementally: 
Update pages at a time VS component by component updates
Page by page might still be better from an implementation standpoint? The front end devs may be able to do that quickly. Each page is a new route in the <App>
html
<div id=“app”></div>
Singular root.render call
js
root.render(<App {...container!.dataset} />);
Component by component: If your page is not fully built with React you have to call createRoot multiple times to create a root for each top-level piece of UI managed by React. You then display different content in each root by calling root.render. 
https://react.dev/reference/react-dom/client/createRoot#rendering-a-page-partially-built-with-react
 
This could get pretty verbose with every component sprinkled throughout the app (100’s of root.render calls).
We would likely have to call root.render for every button, badge, alert, etc.
If we then finally migrate to full pages in React it might prove difficult recomposing the pages.
js
import './styles.css';
import { createRoot } from 'react-dom/client';
import { Comments, Navigation } from './Components.js';

const navDomNode = document.getElementById('navigation');
const navRoot = createRoot(navDomNode); 
navRoot.render(<Navigation />);

const commentDomNode = document.getElementById('comments');
const commentRoot = createRoot(commentDomNode); 
commentRoot.render(<Comments />);
2. How is 
PayerPortal\PayerPortal.Host.UI\public\index.html
 getting added to MyIIS, if at all?
3. design-system as a singular repo with the same components used in both the PayerPortal and BillerPortal but different design tokens applied for the styling (I believe we did something similar at DonorDrive). We could have something like a global prop that determines whether the payer or biller styles get applied to any given component and only load the necessary module.scss file. 
Benefits
Removes duplication
Maintains greater level of consistency
Easier maintenance
Single source of truth
Move all components out of PayerPortal repo into design-system repo. We could then create a private 
design-system
 npm package and import components from that package into PayerPortal and keep PayerPortal for the composed pages.
design-system
 = components only
Built out accessible payer components awhile back here 
https://accessible-payer-inventory.netlify.app/
 based on Figma file: 
Accessible Component Library 1.0
Github link
 (currently private repo)
PayerPortal
 = imported components composed into pages (with payer portal design styles applied)
Later: 
BillerPortal
 = imported components composed into pages (with biller portal design styles applied)
4. The payer-design-system folder is nested in the ‘Components’ folder within the PayerPortal repo?
are these components different from the components in the same folder?
5. Is there any existing documentation or road map the previous team was using that would be helpful for us to take a look at?
Repos
Src - PayerPortal
Src - PayerPayByTextUI – 
just a README?
Src - PayerSupportUI 
Outsource_Altimetrik_Src - design-system1.5 – 
just a README?
Bridge between design & code
Figma Code Connect 
Figma Code Connect
 
“With Code Connect, bring your design system component code directly into Figma's Dev Mode…When using Code Connect, Dev Mode displays real world code snippets defined by your design system 
instead of the autogenerated code
 snippets that Dev Mode provides by default.”
https://www.figma.com/blog/introducing-code-connect/
 
“when a developer clicks on a mockup, they don’t need to search through a bunch of documentation and code to figure out how to build it in the design system. Instead, they just click on it and get the approved, maintained code samples they need, published by the design systems team.
This has huge benefits: Since developers aren’t rewriting components, there’s less code to maintain. By using what’s already there—
rather than creating components from scratch
—developers can work more efficiently and effectively. And with better adherence to your design system, you can more easily improve accessibility and consistency across applications.”
https://github.com/figma/code-connect/blob/main/cli/README.md
 (React installation instructions)
Pros
Designers already use Figma and front end devs/PMs are already familiar with it
Supports React specifically
Free with our current account?
Can see components in context of design and view code snippets
Cons
In beta at the moment.
Bit.cloud
https://bit.cloud/
 
Pros
Existing repos' components already wired up to use this
Interesting component dependency graph
Cons
Cost: $$ goes up quite a bit when we exceed a certain number of components?
Separate from the designer’s tool: Figma
Components and their code snippets live separately from examples of them being used in context in Figma designs.
Has a figma integration but not as robust 
https://bit.cloud/bitdesign/figma/figma-embed
 
Keep/Remove
PayerPortal
Keep 
.tsx
 files over plain 
.jsx
. TypeScript is grrrrrreat 
 
 
Could look at increasing the TS strictness over time
Keep scss modules for components and remove styled-components package/code for consistency. Only one file 
PayperPortal.Host.UI/src/Components/payer-design-system/grid/grid.jsx
 uses styled components package. Most of the components aren’t using modules for styles right now, they’re importing tiny style.css files but that’s an easy fix. 
Benefits of keeping scss modules:
Encapsulation of styles for better organization (and no naming collisions)
Reusability of styles across multiple components.
Improved maintainability of styles.
You can know exactly what styles needs to be loaded for a page, thus reducing the size of the CSS bundle
4 files in the design-system repo are already using .module.scss
scss gives us many advantages over vanilla css
Issues with styled components
Styled Components rely on JavaScript to generate and inject styles, leading to potential performance implications, especially in large apps
Managing global styles or theming can be more complex in Styled Components compared to traditional CSS approaches.
The class names generated by Styled Components are often obfuscated, making it harder to inspect styles in the browser’s developer tools.
Suggestion: keep most of the project folder structure the same with some minor adjustments
This is a simple launching point for a project structure and there seems to be a good amount of existing similarities already:
https://github.com/alan2207/bulletproof-react/blob/master/docs/project-structure.md
 
html
src
|
+-- app               # application layer containing:
|   |
|   +-- routes        # application routes / can also be called pages
    +-- app.tsx       # main application component
    +-- app-provider  # application provider that wraps the entire application with global providers
+-- assets            # assets folder can contain all the static files such as images, fonts, etc.
|
+-- components        # shared components used across the entire application
|
+-- config            # global configurations, exported env variables etc.
|
+-- features          # feature based modules
|
+-- hooks             # shared hooks used across the entire application
|
+-- lib               # reusable libraries preconfigured for the application
|
+-- stores            # global state stores
|
+-- test              # test utilities and mocks
|
+-- types             # shared types used across the application
|
+-- utils             # shared utility functions
If a folder has more than 10 files, consider restructuring it
In the components folder, consider just housing the 
.tsx
 and 
.module.scss
 files in the root instead of individual component folders
+-- components
|   |
|   +-- button.tsx
    +-- button.module.scss
this avoids additional folder nesting and longer, repetitive import statements that can occur when utilizing style modules imported at the top of the component’s .tsx file:
import { button } from './components/button/button';
 
In the current project structure the PayByText 
page
 is currently in the ‘Components’ directory
PayerPortal/PayerPortal.Host.UI/src/Components/PayByText/index.tsx
We’ll want to move that out to it’s own ‘pages’ directory or something of that nature
This page file is 1267 lines long
We will want to separate out a lot of this into separate utility functions, separate components, separate subcomponents etc. so that this becomes a smaller, easier to understand, maintainable file.
There are several side effects like API calls, localStorage operations within the component body. These should be separated out either into a useEffect call or a custom hook to avoid unnecessary re-renders.
Remove bootstrap and jquery
Remove all 
&nbsp;
 for spacing — use padding/margin instead
Remove all use of inline styles in favor of class names from scss modules and global scss modules
Follow the front end formatting standards documentation we started here:
Front End Formatting Standards
 
Utilize Prettier for help with this
Remove all unused variables, imports, interfaces, and types etc.
We might benefit from the Next.js react framework 
https://nextjs.org/
 
File based routing
Define pages and routes with files and folders
Page prerendering with either:
Static Generation (typically the approach to use)
Server-side rendering
Better for SEO b/c we’re not serving up a sparse HTML skeleton
 URL:/spaces/PRODUCT/pages/3361046548/React+Component+Discussion