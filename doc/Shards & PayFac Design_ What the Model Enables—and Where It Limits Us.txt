We run a 
shard-per-biller
 model in Azure SQL. It’s great for isolation, performance, and biller‑specific reporting. When layering a 
PayFac
 (payments lifecycle, funding/NACHA, reporting) on top, the shard model primarily impacts 
cross-biller operations
, including aggregations, funding orchestration, and parent-entity reporting. 
What is the Shard Model? 
One database per biller
 ("shard"): operational data and biller reporting live for that one biller.
Where shards constrain PayFac design
Cross‑shard aggregation
Limitation: We cannot do true global queries in one shot; we must fan out across shards.
Impact: Parent entities (e.g., groups that own multiple billers) and enterprise rollups are not real‑time without extra plumbing. (“SuperBiller”)
Funding orchestration (NACHA)
Limitation: Funding is a global process, but payment/funding details are scattered per shard.
Impact: To create payouts/NACHA, we must know 
which shards
 to pull from and 
correlate
 payments across systems.
Consistency between PayFac core and shards
Limitation: PayFac events (payments, funding-instructions, ledger) live in a 
multi‑tenant
 store; shards are biller‑local.
Impact: We operate 
eventual consistency
; drift can occur without guardrails.
Schema & feature rollout
Limitation: Changes touching payment fields may require updates across 
every shard
. 
Impact: Increased Engineering effort if shards need new changes. (Ex: Payments Schema, Batch Processes, etc.) 
 URL:/spaces/EA/pages/4603183572/Shards+PayFac+Design+What+the+Model+Enables+and+Where+It+Limits+Us