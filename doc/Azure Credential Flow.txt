Documentation
The 
DefaultAzureCredential
 flow follows the default precedence hierarchy (diagram below) when determining where to obtain the Application's Azure Credentials when an Application is run.   
To change this default flow, credential sources within the 
DefaultAzureCredential
 flow can be skipped as shown in the following code snippet:
if (UseLocal)
{
    credential = new DefaultAzureCredential(new DefaultAzureCredentialOptions { 
        ExcludeEnvironmentCredential = true,
        ExcludeManagedIdentityCredential = true,
        ExcludeSharedTokenCacheCredential = true 
    });
}
else if (!string.IsNullOrEmpty(clientId))
{
    credential = new ManagedIdentityCredential(clientId);
}
else
{
    credential = new ManagedIdentityCredential();
}

var context = new TokenRequestContext(scopes: new string[] { authEndpointUrl + "/.default" });
var newAccessToken = credential.GetToken(context, CancellationToken.None);
Additionally, a custom flow can be defined as shown in the following code snippet:
var tokenCredential = new ChainedTokenCredential(
    new AzureCliCredential(),
    new DefaultAzureCredential());

_ = await tokenCredential.GetTokenAsync(new TokenRequestContext(new[] { "https://graph.microsoft.com/.default" }));
The following link provides additional information on this topic: 
https://anthonysimmon.com/defaultazurecredential-local-development-optimization/
 
InvoiceCloud Implementation
This functionality is implemented for use by InvoiceCloud applications within the following Repo: 
https://dev.azure.com/invoicecloud/Src/_git/IC.ApplicationAuthService
However the functionality does not behave as expected when run locally on an AVD because the AVDâ€™s System Assigned Managed Identity interferes with the Developer Credential stores as shown in the code snippet below taken from the 
AccessTokenService.cs
:
bool useLocal = this.UseLocal;
            
var accessToken = this._tokenCache.GetOrAdd(
	cacheKey,
	(key) =>
	{
		TokenCredential credential = null;

		if (useLocal)
		{
			credential = new DefaultAzureCredential();
		}
		else if (!string.IsNullOrEmpty(clientId))
		{
			credential = new ManagedIdentityCredential(clientId);
		}
		else
		{
			credential = new ManagedIdentityCredential();
		}

		try
		{
			logger.Info($"Requesting new access token for {authEndpointUrl}");

			var context = new TokenRequestContext(scopes: new string[] { authEndpointUrl + "/.default" });
			var newAccessToken = credential.GetToken(context, CancellationToken.None);

			logger.Info($"Successfully requested new access token for {authEndpointUrl} expires on {newAccessToken.ExpiresOn}");

			return newAccessToken;
		}
		catch (Exception x)
		{
			logger.Error($"Failed requesting new access token for {authEndpointUrl}, {x}");
			var ex = new AccessTokenServiceException("Failed obtaining an Access Token. Please check the clientid.", x);
			throw ex;
		}
	}
);
Proposed Fix
There are a couple proposed fixes for this unexpected behavior:
Jira Card with one option
EBPP-13155
2278e126-27dc-36c8-aef9-a32d91bc7ad7
System Jira
 
Branch with another option
https://dev.azure.com/invoicecloud/Src/_git/IC.ApplicationAuthService?version=GBfix%2FEBPP-12145%2Ffix-use-local
 URL:/spaces/platform/pages/3013148783/Azure+Credential+Flow