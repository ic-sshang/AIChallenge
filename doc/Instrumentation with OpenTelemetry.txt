Overview
This guide demonstrates basic instrumentation of .NET applications using the OpenTelemetry SDKs - including both Metrics & Traces.
Prerequisites
Ensure that you’ve completed the OTEL setup for your application
https://invoicecloud.atlassian.net/wiki/spaces/PMK/pages/4450484261/Open+Telemetry+Setup+-+.Net+Web+API?atlOrigin=eyJpIjoiMjYzYjJiNWNlNTk4NGRlOTgxOTc4MzFiMWUwNmM1NDEiLCJwIjoiYyJ9
 
https://invoicecloud.atlassian.net/wiki/spaces/PMK/pages/4451205134/Open+Telemetry+Setup+-+.Net+Job?atlOrigin=eyJpIjoiYjY0MTk3ZjJiNTUyNGY1ZmI4NDRlYWFlMWQ5OTIyNzMiLCJwIjoiYyJ9
 
Take a look at the OTEL Semantic Conventions for both Metrics & Traces - these provide best-practices and naming guidelines.
Metrics semantic conventions | OpenTelemetry
Trace semantic conventions | OpenTelemetry
Create an 
InstrumentationSource
It is best to create a single class internal to a given service that exposes all of the instrumentation providers needed for creating custom metrics and traces. It is up to you if you wish to create this class against an interface definition or not, however, there are two important things to keep in mind
Ensure that the class is easily identifiable as a single source of Open Telemetry configuration - 
Instrumentation
, 
InstrumentationSource
, 
OpenTelemetryConfiguration
, etc.
Ensure that the class implements 
IDisposable
 and properly cleans up unmanaged resources using the 
Dispose()
 pattern.
c#
public class InstrumentationSource: IDisposable
{
    public InstrumentationSource(string serviceName)
    {
      // TODO
    }

  # region IDisposable
    private bool _disposed = false;
    
    ~InstrumentationSource()
     {
         Dispose(false);
     }

    public void Dispose()
    {
      
    }

    public virtual void Disposing(bool disposing)
    {
      if(!_disposed) 
      {
          if(disposing)
          {
             // TODO
             // Dispose of unmanaged resources
             // this.ActivitySource.Dispose();
             // this._meter.Dispose();
          }

          _disposed = true;
      }  
    }
  #endregion
}
Note that the above 
InstrumentationSource
 class is going to be used in subsequent examples, and while relevant bits will be highlighted where applicable, much of the above will be excluded for brevity.
Once that’s been established - go ahead and register it with the IoC container. This process will be more or less the same between a .NET Web API, MVC, Console App, or Worker Service project. 
c#
var serviceName = hostContext.Configuration.GetValue<string>("OTEL_SERVICE_NAME");

services.RegisterSingleton(_ => new InstrumentationSource(serviceName));
// OR if you created an interface - this may be easier to mock for unit testing.
// services.RegisterSingleton<IInstrumentationSource>(_ => new InstrumentationSource(serviceName))
Add and use an 
ActivitySource
Once the 
InstrumentationSource
 has been created and registered in the application startup, we’re ready to begin adding custom traces and metrics. We’ll start here with custom trace events. The .NET implementation of OpenTelemetry conveniently uses existing observability tools from the 
System.Diagnostics
 namespace.
To begin - we’ll add an 
ActivitySource
 instance field to our 
InstrumentationSource
 class:
c#
using System.Diagnostics;

public class InstrumentationSource: IDisposable
{   
    public ActivitySource ActivitySource { get; }
  
    public InstrumentationSource(string serviceName)
    {
        this.ActivitySource = new ActivitySource(serviceName);
    }
}
Next, we’ll inject our 
InstrumentationSource
 into an area that we wish to add observability to:
c#
public class MySuperImportantClass
{
    private readonly ActivitySource _activitySource;
    public MySuperImportantClass(InstrumentationSource instrumentation)
    {
        this._activitySource = instrumentation.ActivitySource;
    }
}
Once this is done - traces can be created over target areas
c#
using var activity = this._activitySource.StartActivity("MyActivityToTrace");

// Set up a collection of identifying tags.
var eventTags = new ActivityTagsCollection
{
  { "operation", "MyMethodName" },
  { "correlation_id", "MyCorrelationId" },
  { "tenant_id", "MyBillerOrPayerId" },
  { "item_id", "AnotherIdentifier" }
};

// Start the activity
activity.AddEvent(new("Began Doing Work", DateTimeOffset.UtcNow, eventTags));

// Do stuff
activity.AddEvent(new("Something Happened", DateTimeOffset.UtcNow, eventTags));

// Do other stuff
activity.AddEvent(new("Something Else Happened", DateTimeOffset.UtcNow, eventTags));

// End the activity
activity.AddEvent(new("Done doing work", DateTimeOffset.UtcNow, eventTags));

Note that the 
eventTags
 are used to add additional context to the Activity - in the example above, we keep track of the executing method, correlation Id of the request, tenant Id indicating who the request is being run for, and have an additional property that could be an identifier for some other resource belonging to the tenant, like a report Id or an employee or asset number.
Add and use a 
Meter
To create custom metrics via OTEL - we can use the 
Meter
 class from the 
System.Diagnostics.Metrics
 namespace. The pattern is very similar to the one implemented before for custom traces.
c#
using System.Diagnostics;

public class InstrumentationSource: IDisposable
{   
    private readonly Meter _meter;
  
    public InstrumentationSource(string serviceName)
    {
        this._meter = new Meter(serviceName);
    }
}
To add a twist to this implementation - we also need to create different metric sources using the 
Meter
 class. We’ll use two different types in the examples below - a 
Counter<T>
 and 
Histogram<T>
. These are two examples, but there are additional Meter types 
available in the System.Diagnostics.Metrics namespace. 
c#
using System.Diagnostics;

public class InstrumentationSource: IDisposable
{   
    private readonly Meter _meter;

    public Counter<long> ItemsProcessed { get; }
    public Histogram<double> RequestLatency { get; }
  
    public InstrumentationSource(string serviceName)
    {
        this._meter = new Meter(serviceName);

        ItemsProcessed = this._meter.CreateCounter<long>("domain.serviceName.items_processed", "count", "The number of items processed.");
        RequestLatency = this._meter.CreateHistogram<double>("domain.serviceName.request_latency", "ms", "The time it takes to perform work."); 
    }
}
note
Note - 
the OTEL Semantic conventions for Metrics
 indicate
Naming conventions
 should adhere to a namespace-based approach - the example above uses 
domain.serviceName.metric_name
, following established guidelines.
Metric names 
should NOT include units
 in the metric name - the Histogram is really recording latency in milliseconds - but it is excluded from the name & provided as the unit value instead
CreateHistogram<double>("domain.serviceName.request_latency", "ms", "The time it takes to perform work.");


Note - 
the OTEL Semantic conventions for Metrics
 indicate
Naming conventions
 should adhere to a namespace-based approach - the example above uses 
domain.serviceName.metric_name
, following established guidelines.
Metric names 
should NOT include units
 in the metric name - the Histogram is really recording latency in milliseconds - but it is excluded from the name & provided as the unit value instead
CreateHistogram<double>("domain.serviceName.request_latency", "ms", "The time it takes to perform work.");


The 
Histogram
 specifically represents an aggregation of values and provides a mechanism to compare a range of values individually, rather than viewing them as a total or average value. In order to properly configure this meter type, we also need to add a View to our OTEL configuration at startup.
c#
services
    .AddOpenTelemetry()
    .WithMetrics(metrics = {
      metrics
        .SetResourceBuilder(resourceBuilder)
        .AddMeter(serviceName)
        .AddView("domain.serviceName.request_latency", new ExplicitBucketHistogramConfiguration {
          Boundaries = [10.0, 100.0, 300.0, 500.0, 1000.0, 3000.0, 5000.0, 10000.0, 1000000.0]
        })
        // etc.
    });
Now, we can use the two established 
Meter
 instruments in areas of the code where we want to collect information. First, establish the instruments in the relevant place using the same 
InstrumentationSource
 as before.
c#
public class MySuperImportantClass
{
    private readonly ActivitySource _activitySource;
    private readonly Counter<long> _itemsProcessed;
    private readonly Histogram<double> _requestLatency;
    
    public MySuperImportantClass(InstrumentationSource instrumentation)
    {
        this._activitySource = instrumentation.ActivitySource;
        this._itemsProcessed = instrumentation.ItemsProcessed;
        this._requestLatency = instrumentation.RequestLatency;
    }
}
Now, we can use the instruments in the code to capture insights.
c#
public async Task MyMethod(ReceivedEvent @event)
{
    var stopwatch = StopWatch.StartNew();
    try
    {
       // Do some work.

      // Increment the Counter
      this._itemsProcessed.Add(1, new KeyValuePair<string, object>("tenant.id", @event.TenantId))
    }
    catch
    {
      // Handle errors
    }
    finally
    {
       stopwatch.Stop();
      
       // Record the total time it took to perform the work.
       this._requestLatency.Record(stopwatch.Elapsed.TotalMilliseconds,  new KeyValuePair<string, object>("tenant.id", @event.TenantId))
    }
}
Note the 
KeyValuePair<string, object>
 objects passed to the instruments above. Similar to the 
ActivitySource
 example above, the APIs for all 
Meter
 instruments allow one or more of these to be provided when logging data - either as 
KeyValuePair<string, object>
 or as a 
TagList
 data structure. These can help make metrics more meaningful and provide more granular context to specific activities.
Final Details
Ensure that you complete implementing the 
IDisposable
 pattern in your 
InstrumentationSource
 - dispose of both your 
ActivitySource
 and 
Meter
 as part of the disposal logic.
c#
public virtual void Disposing(bool disposing)
{
    if(!_disposed) 
    {
        if(disposing)
        {
            this.ActivitySource.Dispose();
            this._meter.Dispose();
         }

          _disposed = true;
     }  
}
Resources
Metrics - 
System.Diagnostics.Metrics Namespace | Microsoft Learn
Traces - 
System.Diagnostics Namespace | Microsoft Learn
Instrumentation | OpenTelemetry
.NET Observability with OpenTelemetry - .NET | Microsoft Learn
Naming | OpenTelemetry
 URL:/spaces/PMK/pages/4497637798/Instrumentation+with+OpenTelemetry