This doc describes the proposed design for Payments schema to also account for idempotency and racing scenarios. There will be more iterations on that. This is just to record the current state. More details on idempotency and racing scenarios on Payments can be found here: 
Payments API: Idempotency & Race Condition Handling
 
Note
: the column names to be renamed to fit in IC naming conventions.
Diagram:
DBML:
sql
Table Currencies {
  CurrencyCode string [pk]
  CurrencyName string 
}

Table Customers {
  CustomerID int [pk, increment]
  CustomerName string 
  EmailAddress string 
}

Table Locations {
  LocationID int [pk, increment]
  City string 
  State string 
  Zip string 
}

Table PaymentStatuses {
  PaymentStatusID int [pk, increment]
  PaymentStatusName string
}

Table Payments {
  PaymentID int [pk, increment]
  SubmerchantKey string
  Amount decimal 
  ConvenienceFee decimal 
  PaymentDate datetime 
  PaymentStatusID string
  TransactionTypeID int 
  TraceNumber string [unique]
  PaymentReferenceID string 
  PaymentMessage text 
  InvoiceNumber string 
  CustomerID int 
  LocationID int 
  CurrencyCode string 
  CreditForPaymentID int 
  CreditStatusID int
  IdempotencyKey string [unique]
  UpdatedAt datetime 
  MerchantOrderNumber string [unique]
  ChaseTransactionId string
  BillerID int
}

Table VoidRequests {
  VoidRequestID int [pk, increment]
  PaymentID int 
  IdempotencyKey string [unique]
  RequestedAt datetime 
}

Table AuditLog {
  AuditID int [pk, increment]
  EntityType string 
  EntityID string 
  ActionType string 
  ActionTimestamp datetime 
  PerformedBy string 
  OldValue json 
  NewValue json 
}

Ref: Customers.CustomerID < Payments.CustomerID
Ref: Locations.LocationID < Payments.LocationID
Ref: PaymentStatuses.PaymentStatusID < Payments.PaymentStatusID
Ref: PaymentStatuses.PaymentStatusID < Payments.CreditStatusID
Ref: Currencies.CurrencyCode < Payments.CurrencyCode
Ref: Payments.PaymentID < Payments.CreditForPaymentID
Ref: Payments.PaymentID < VoidRequests.PaymentID
Sample SQL with sprocs to showcase the idempotency
sql
-- PaymentReferenceID - comes from CTP. generated GUID. to be persisted on CTP side as well to tie IC to our system


-- Table: Currencies
CREATE TABLE Currencies (
    CurrencyCode VARCHAR(3) PRIMARY KEY,
    CurrencyName VARCHAR(50),
    Symbol VARCHAR(5)
);

-- Table: Customers: to decide
CREATE TABLE Customers (
    CustomerID INT AUTO_INCREMENT PRIMARY KEY,
    CustomerName VARCHAR(100),
    EmailAddress VARCHAR(100)
);

-- Table: Locations
CREATE TABLE Locations (
    LocationID INT AUTO_INCREMENT PRIMARY KEY,
    City VARCHAR(100),
    State VARCHAR(100),
    Zip VARCHAR(20)
);

-- Table: Payments
CREATE TABLE Payments (
    PaymentID INT AUTO_INCREMENT PRIMARY KEY,
    TerminalID VARCHAR(50),
    Amount DECIMAL(10,2),
    ConvenienceFee DECIMAL(10,2),
    PaymentDate DATETIME,
    PaymentStatusID --Status VARCHAR(50),
    TransactionTypeID INT,
    TraceNumber VARCHAR(100) UNIQUE,
    PaymentReferenceID VARCHAR(100),   ---
    PaymentTypeID INT,
    PaymentMessage TEXT,
    InvoiceNumber VARCHAR(100),
    CustomerID INT,
    LocationID INT,
    CurrencyCode VARCHAR(3),
    RefundForPaymentID INT, -- if the record is not refund, this should be 0; if the record is refund - this ties to the PaymentID for the original Payment
    RefundReason TEXT,
    RefundStatusID-- RefundStatus VARCHAR(50),
    IdempotencyKey VARCHAR(100) UNIQUE,
    UpdatedAt DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
	ChaseTransactionId VARCHAR(100), -- 1:1 to payments record; is needed for voids and refunds
	MerchantID INT, -- tie to merchants table for us to pass to refunds/voids
	TotalRefundedAmount DECIMAL(10,2) DEFAULT 0, -- used to keep track of refund
    FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID),
    FOREIGN KEY (LocationID) REFERENCES Locations(LocationID),
    FOREIGN KEY (CurrencyCode) REFERENCES Currencies(CurrencyCode),
    FOREIGN KEY (RefundForPaymentID) REFERENCES Payments(PaymentID)
);

-- original payment
-- 1, ..., 0, 100 USD
-- 2, ..., 1, 50 USD
-- 3, ..., 1, 10 USD

-- Table: PaymentStatuses
-- PaymentStatusID PK

-- Table: RefundStatuses
-- RefundStatusID PK

-- Table: VoidRequests
CREATE TABLE VoidRequests (
    VoidRequestID INT IDENTITY PRIMARY KEY,
    PaymentID INT NOT NULL,
    IdempotencyKey VARCHAR(100) UNIQUE NOT NULL,
    RequestedAt DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (PaymentID) REFERENCES Payments(PaymentID)
);


-- Table: ExchangeRates
CREATE TABLE ExchangeRates (
    FromCurrencyCode VARCHAR(3),
    ToCurrencyCode VARCHAR(3),
    Rate DECIMAL(18,6),
    EffectiveDate DATE,
    PRIMARY KEY (FromCurrencyCode, ToCurrencyCode, EffectiveDate),
    FOREIGN KEY (FromCurrencyCode) REFERENCES Currencies(CurrencyCode),
    FOREIGN KEY (ToCurrencyCode) REFERENCES Currencies(CurrencyCode)
);

-- Table: AuditLog - record any insert and update (to replace ChangeLog)
CREATE TABLE AuditLog (
    AuditID INT AUTO_INCREMENT PRIMARY KEY,
    EntityType VARCHAR(50),
    EntityID VARCHAR(100),
    ActionType VARCHAR(50),
    ActionTimestamp DATETIME,
    PerformedBy VARCHAR(100),
    OldValue JSON,
    NewValue JSON
);

-- normalize Audit

-- idempotency. work out if we need a separate idempotency table with request and response

-- Stored Procedure: InsertPayment
DELIMITER $$

CREATE PROCEDURE InsertPayment (
    IN p_TerminalID VARCHAR(50),
    IN p_Amount DECIMAL(10,2),
    IN p_ConvenienceFee DECIMAL(10,2),
    IN p_PaymentDate DATETIME,
    IN p_Status VARCHAR(50),
    IN p_TransactionTypeID INT,
    IN p_TraceNumber VARCHAR(100),
    IN p_PaymentReferenceID VARCHAR(100),
    IN p_PaymentTypeID INT,
    IN p_PaymentMessage TEXT,
    IN p_InvoiceNumber VARCHAR(100),
    IN p_CustomerID INT,
    IN p_LocationID INT,
    IN p_CurrencyCode VARCHAR(3),
    IN p_IdempotencyKey VARCHAR(100),
    IN p_PerformedBy VARCHAR(100)
)
BEGIN
    DECLARE v_PaymentID INT;

    START TRANSACTION;

    -- Check for existing payment by IdempotencyKey
    SELECT PaymentID INTO v_PaymentID
    FROM Payments
    WHERE IdempotencyKey = p_IdempotencyKey;

    IF v_PaymentID IS NOT NULL THEN
        -- Return existing payment
        SELECT v_PaymentID AS PaymentID;
        ROLLBACK;
    ELSE
        -- Insert new payment
        INSERT INTO Payments (
            TerminalID, Amount, ConvenienceFee, PaymentDate, Status,
            TransactionTypeID, TraceNumber, PaymentReferenceID, PaymentTypeID,
            PaymentMessage, InvoiceNumber, CustomerID, LocationID,
            CurrencyCode, IdempotencyKey
        )
        VALUES (
            p_TerminalID, p_Amount, p_ConvenienceFee, p_PaymentDate, p_Status,
            p_TransactionTypeID, p_TraceNumber, p_PaymentReferenceID, p_PaymentTypeID,
            p_PaymentMessage, p_InvoiceNumber, p_CustomerID, p_LocationID,
            p_CurrencyCode, p_IdempotencyKey
        );

        SET v_PaymentID = LAST_INSERT_ID();

        -- Insert audit log
        INSERT INTO AuditLog (
            EntityType, EntityID, ActionType, ActionTimestamp, PerformedBy, OldValue, NewValue
        )
        VALUES (
            'Payment', v_PaymentID, 'Created', NOW(), p_PerformedBy, NULL,
            JSON_OBJECT(
                'TerminalID', p_TerminalID,
                'Amount', p_Amount,
                'CurrencyCode', p_CurrencyCode,
                'Status', p_Status
            )
        );

        COMMIT;

        SELECT v_PaymentID AS PaymentID;
    END IF;
END$$

-- Stored Procedure: UpdatePaymentStatus
CREATE PROCEDURE UpdatePaymentStatus (
    IN p_PaymentID INT,
    IN p_NewStatus VARCHAR(50),
    IN p_PerformedBy VARCHAR(100)
)
BEGIN
    DECLARE v_OldStatus VARCHAR(50);
    DECLARE v_UpdatedAt DATETIME;

    START TRANSACTION;

    -- Lock the row and get current status
    SELECT Status, UpdatedAt INTO v_OldStatus, v_UpdatedAt
    FROM Payments
    WHERE PaymentID = p_PaymentID
    FOR UPDATE;

    -- Update the payment status
    UPDATE Payments
    SET Status = p_NewStatus
    WHERE PaymentID = p_PaymentID;

    -- Insert audit log
    INSERT INTO AuditLog (
        EntityType, EntityID, ActionType, ActionTimestamp, PerformedBy, OldValue, NewValue
    )
    VALUES (
        'Payment',
        p_PaymentID,
        'Updated',
        NOW(),
        p_PerformedBy,
        JSON_OBJECT('Status', v_OldStatus),
        JSON_OBJECT('Status', p_NewStatus)
    );

    COMMIT;
END$$

DELIMITER ;

-- Process Void sproc
CREATE PROCEDURE ProcessVoid (
IN p_PaymentID INT,
IN p_IdempotencyKey VARCHAR(100),
IN p_PerformedBy VARCHAR(100)
)
BEGIN
DECLARE v_ExistingRequestID INT;
DECLARE v_CurrentStatus VARCHAR(50);
DECLARE v_VoidRequestID INT;

START TRANSACTION;

-- Check for existing void request with the same IdempotencyKey
SELECT VoidRequestID INTO v_ExistingRequestID
FROM VoidRequests
WHERE IdempotencyKey = p_IdempotencyKey;

IF v_ExistingRequestID IS NOT NULL THEN
-- Return existing request
SELECT v_ExistingRequestID AS VoidRequestID;
ROLLBACK;
LEAVE;
END IF;

-- Lock the payment row and get current status
SELECT Status INTO v_CurrentStatus
FROM Payments
WHERE PaymentID = p_PaymentID
FOR UPDATE;

-- Check if already voided or in progress
IF v_CurrentStatus IN ('Voided', 'PendingVoid') THEN
ROLLBACK;
SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Payment already voided or in progress';
END IF;

-- Insert void request
INSERT INTO VoidRequests (PaymentID, IdempotencyKey)
VALUES (p_PaymentID, p_IdempotencyKey);

SET v_VoidRequestID = LAST_INSERT_ID();

-- Update payment status
UPDATE Payments
SET Status = 'PendingVoid'
WHERE PaymentID = p_PaymentID;

-- Insert audit log
INSERT INTO AuditLog (
EntityType, EntityID, ActionType, ActionTimestamp, PerformedBy, OldValue, NewValue
)
VALUES (
'VoidRequest', v_VoidRequestID, 'Created', NOW(), p_PerformedBy, NULL,
JSON_OBJECT('PaymentID', p_PaymentID, 'Status', 'PendingVoid')
);

COMMIT;

SELECT v_VoidRequestID AS VoidRequestID;
END$$

DELIMITER ;

-- Refund sproc
DELIMITER $$
CREATE PROCEDURE ProcessRefund (
    IN p_OriginalPaymentID INT,
    IN p_Amount DECIMAL(10,2),
    IN p_IdempotencyKey VARCHAR(100),
    IN p_PerformedBy VARCHAR(100)
)
BEGIN
    DECLARE v_OriginalAmount DECIMAL(10,2);
    DECLARE v_TotalRefunded DECIMAL(10,2);
    DECLARE v_RefundPaymentID INT;
    START TRANSACTION;
    SELECT Amount INTO v_OriginalAmount
    FROM Payments
    WHERE PaymentID = p_OriginalPaymentID
    FOR UPDATE;
    SELECT IFNULL(SUM(Amount), 0) INTO v_TotalRefunded
    FROM Payments
    WHERE RefundForPaymentID = p_OriginalPaymentID;
    IF p_Amount + v_TotalRefunded > v_OriginalAmount THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Refund exceeds original payment amount';
    END IF;
    IF EXISTS (
        SELECT 1 FROM Payments WHERE IdempotencyKey = p_IdempotencyKey
    ) THEN
        SELECT PaymentID AS RefundPaymentID
        FROM Payments
        WHERE IdempotencyKey = p_IdempotencyKey;
        ROLLBACK;
        LEAVE;
    END IF;
    INSERT INTO Payments (
        TerminalID, Amount, PaymentDate, Status, PaymentReferenceID,
        PaymentTypeID, CustomerID, LocationID, CurrencyCode,
        RefundForPaymentID, IdempotencyKey
    )
    SELECT
        TerminalID, p_Amount, NOW(), 'PendingRefund', PaymentReferenceID,
        PaymentTypeID, CustomerID, LocationID, CurrencyCode,
        p_OriginalPaymentID, p_IdempotencyKey
    FROM Payments
    WHERE PaymentID = p_OriginalPaymentID;
    SET v_RefundPaymentID = LAST_INSERT_ID();
    INSERT INTO AuditLog (
        EntityType, EntityID, ActionType, ActionTimestamp, PerformedBy, OldValue, NewValue
    )
    VALUES (
        'Payment', v_RefundPaymentID, 'Created', NOW(), p_PerformedBy, NULL,
        JSON_OBJECT('RefundForPaymentID', p_OriginalPaymentID, 'Amount', p_Amount)
    );
    COMMIT;
    SELECT v_RefundPaymentID AS RefundPaymentID;
END$$
DELIMITER ;

 URL:/spaces/EA/pages/4509040734/Proposed+Payments+Schema+-+WIP+-+Draft+V2