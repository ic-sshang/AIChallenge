Zero Start Environment Configurations
Do not check-in configurations that are specific to a environment into Source Control.  If you want to have configurations for ease of development add them as a README or a different file that can not be accidently deployed and or consumed by a deployment.   Required configurations should be validated on startup and we do not want dev configurations accidently being deployed to production which could delay surfacing issues later ( like a production assets using dev assets ).   Pipelines are used to deploy applications and their  environment specific configurations.  
Having defaults increases the risk of missing the injection of a particular configuration by the deployment pipeline.
Use Configuration Files
Store configurations settings in separate configuration files rather than hardcoding values into the code.  This allows for easy changes without modifying the application's codebase.
Configuration Sources
Utilize multiple configuration sources; environment variables, command line arguments, and user secrets, in addition to configuration files.  This enables flexibility and helps manage configuration for different environments.
Appropriate Configuration Provider
Use the appropriate configuration providers based on the use case.  For example use 
AddJsonFile 
for JSON files and local development and 
AddEnvironmentVariables
 for environment variables for running in containers.
Sensitive Data Protection
Keep sensitive configuration data (passwords, API credentials) out of source control.  Use user secrets or a secure configuration store, like a key vault, to manage sensitive data during development and deployments.
Configuration Validation 
Validate configuration settings during application startup.
Configuration Sections and Hierarchies
Organize configuration settings into logical sections and hierarchies within the configuration files.  This improves readability and maintainability as the configuration grows.
Strongly Typed Configuration
Create strongly typed configuration classes to map configuration data to c# objects.  This enhances type safety and provides itellisense support during development.
Immutable Configuration
Treat configuration objects as immutable.  Once loaded, configuration settings should not be changed during the application‚Äôs runtime.
üõ†Ô∏è Developer Guide: Managing 
appsettings.json
 in .NET
üìò Overview
In .NET applications, 
appsettings.json
 is a central configuration file used to store settings like connection strings, API keys, feature flags, and more. While convenient for development, improper handling of this file‚Äîespecially in CI/CD pipelines‚Äîcan lead to 
developer-specific values being deployed to production
, causing outages or security risks.
üìÅ File Structure Best Practices
Use the following layered configuration approach:
wide
760
appsettings.json // Base settings (common to all environments)
appsettings.Development.json // Developer-specific overrides
.NET automatically loads the correct file based on the 
ASPNETCORE_ENVIRONMENT
 variable.
‚úÖ What Developers Should Do
Use 
appsettings.Development.json
 for local overrides only.
Never check in sensitive or environment-specific values into 
appsettings.json
.
Example:
json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=localhost;Database=devdb;..."
  }
}
Avoid modifying 
appsettings.json
 directly for environment-specific values.
This file should contain only shared defaults.
Use secrets management for sensitive values.
Use environment variables or Azure Key Vault in production.
üö® Common Pitfall: Developer Values in Production
Cause:
Pipelines fail to overwrite 
appsettings.json
 (either directly or environment variable overrides)
Developers accidentally check in local values to the base file.
 URL:/spaces/ED/pages/2797371435/Settings+and+Configurations+-+CORE