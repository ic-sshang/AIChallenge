Sensitive Data
: Use 
char[]
 or  
byte[]
 to handle sensitive data securely.
Once your data is in the type string it is no longer able to be predictably cleared after use.
If you have sensitive data itâ€™s better to use a 
char[]
 or 
byte[]
 to store the data, as these can be manually cleared from memory. Strings, being immutable, cannot be modified once created, which means sensitive data will remain memory until the garbage collector reclaims it.  This immutability can lead to multiple copies of the string in memory, which can be problematic for sensitive data.
c#
char[] sensitiveData = new char[] { 's', 'e', 'c', 'r', 'e', 't' };
// Use the data
// Clear the data
Array.Clear(sensitiveData, 0, sensitiveData.Length);
Example
If you need to read sensitive JSON data from a incoming HTTP request read the body as a 
byte[]
.   You can use a custom JSON converter to support converting from a JSON string property to a dotnet 
char[]
 property.
Model
c#
// a example object that has a char array property instead of a string
public class UserSignIn
{
	public string Username { get; set; }
	public char[] Password { get; set; }
}
Custom JSON Converter
c#
// custom JSON converter for char arrays
public class CharArrayJsonConverter : JsonConverter<char[]>
{
	public override char[] Read(
		ref Utf8JsonReader reader,
		Type typeToConvert,
		JsonSerializerOptions options)
	{
		char[] charArray = new char[reader.ValueSpan.Length];
		Decoder decoder = Encoding.UTF8.GetDecoder();
		decoder.Convert(reader.ValueSpan, charArray, true, out int bytesUsed, out int charsUsed, out bool completed);
		return charArray;
	}

	public override void Write(
		Utf8JsonWriter writer,
		char[] value,
		JsonSerializerOptions options)
	{
		writer.WriteStringValue(Encoding.UTF8.GetBytes(value));
	}
}

API Controller
c#

// example API controller
[ApiController]
public class SignInController : ControllerBase
{
    [HttpPost("api/v1/signin")]
    public async Task<IActionResult> Post()
    {
        Request.EnableBuffering(); // use this if the body needs to be read again later
        using (MemoryStream memoryStream = new MemoryStream())
        {
            await Request.Body.CopyToAsync(memoryStream);
            byte[] requestBodyBytes = memoryStream.ToArray();
            
            // create the JSON serialization options to support char arrays
            var serializeOptions = new JsonSerializerOptions
            {
				Converters =
				{
					new CharArrayJsonConverter()
				}
            };
            
            // deserialize bytes to a object with a char array property  
            // use the object        
            var userSignIn = JsonSerializer.Deserialize<UserSignIn>(requestBodyBytes, serializeOptions);

            // clear memory
            Array.Clear(requestBodyBytes, 0, requestBodyBytes.Length);
            Array.Clear(userSignIn.Password, 0, userSignIn.Password.Length);
            
            // For demonstration, we'll just return
            return Ok();
        }
    }
}


 URL:/spaces/ED/pages/3517939724/.Net+Sensitive+Data+In+Memory